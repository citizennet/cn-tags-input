{"version":3,"sources":["all.js","cn-tags-input.js"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","_typeof","Symbol","iterator","constructor","SimplePubSub","events","on","names","handler","split","forEach","name","push","this","trigger","args","angular","call","makeObjectArray","array","key2","length","isObject","item","index","findInObjectArray","i","l","_","isFunction","objVal","has","toJson","toLowerCase","replaceAll","str","substr","newSubstr","expression","replace","RegExp","matchTagsWithModel","tags","model","valueProperty","isArray","some","tag","equals","selectAll","input","setSelectionRange","KEYS","backspace","tab","enter","escape","space","up","down","comma","tagsInput","module","directive","$timeout","$document","tagsInputConfig","$sce","$rootScope","TagList","options","getTagText","setTagText","tagIsValid","self","itemFormatter","displayProperty","text","tagText","minLength","maxLength","allowedTagsPattern","test","items","addText","add","disabled","trim","replaceSpacesWithDashes","maxTags","pop","$tag","$event","remove","splice","removeLast","lastTagIndex","enableEditingLastTag","selected","restrict","require","scope","ngDisabled","onBeforeTagAdded","onBeforeTagRemoved","onBeforeTagChanged","onTagAdded","onTagRemoved","onTagChanged","onInit","newTag","transclude","templateUrl","controller","$scope","$attrs","$element","load","placeholder","String","tabindex","Number","removeTagSymbol","fromCharCode","Boolean","addOnEnter","addOnSpace","addOnComma","addOnBlur","required","minTags","allowLeftoverText","addFromAutocompleteOnly","tagClass","modelType","arrayValueType","hideTags","dropdown","tagsStyle","allowBulk","bulkDelimiter","bulkPlaceholder","showButton","tagList","registerAutocomplete","find","e","addTag","focusInput","focus","blurInput","blur","getTags","getOptions","registerProcessBulk","fn","processBulk","bulkTags","then","showBulk","link","element","attrs","ngModelCtrl","beforeAndAfter","before","after","arguments","apply","onFocus","preventDefault","target","blurTimeout","cancel","hasFocus","val","$root","$$phase","$apply","hotkeys","inputId","$name","pluck","console","log","undefined","invalid","$setValidity","getDisplayText","getDisplayHtml","trustAsHtml","track","newTagChange","each","first","triggerInit","prev","criteria","$prev","$setter","_ref2","$watch","changed","init","match","isUndefined","isDefined","$setDirty","isImmediatePropagationStopped","shouldAdd","shouldRemove","keyCode","isModifier","shiftKey","altKey","ctrlKey","metaKey","addKeys","indexOf","activeElement","prop","lostFocusToBrowserWindow","lostFocusToChildElement","contains","$","closest","$filter","$parse","Api","SuggestionList","debouncedLoadId","getDifference","lastPromise","groupList","splitListItems","formatItemText","mapIndexes","list","groupBy","keys","filtered","map","group","indexes","groups","formatter","addItem","toAdd","childKey","searchKeys","child","array1","array2","filter","reset","visible","query","show","select","promise","filterBy","processItems","isGroups","label","slice","maxResultsToShow","itemMap","data","skipFiltering","isEmpty","source","$query","results","debounceDelay","selectNext","selectPrior","elem","customTemplateUrl","tagsInputCtrl","suggestionList","getItemText","documentClick","highlightMatchedText","dropdownStyle","addSuggestion","added","highlight","addTags","times","batch","multiple","parseInt","_tagsInput$addTag","handled","immediatePropagationStopped","stopImmediatePropagation","stopPropagation","isDefaultPrevented","type","tagName","$on","off","ctrl","transcludeFn","clone","append","span","resize","THRESHOLD","css","parent","originalValue","width","isString","$parsers","unshift","$formatters","$observe","$modelValue","provider","globalDefaults","interpolationStatus","setDefaults","defaults","setActiveInterpolation","$get","$interpolate","converters","uid","uniqueId","localDefault","converter","getDefault","updateValue","globalValue","$parent","run","$templateCache","put"],"mappings":"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","file":"all.min.js","sourcesContent":["'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*!\n * ngTagsInput v2.0.1\n * http://mbenford.github.io/ngTagsInput\n *\n * Copyright (c) 2013-2014 Michael Benford\n * License: MIT\n *\n * Generated at 2014-04-13 21:25:38 -0300\n */\n(function () {\n  'use strict';\n\n  var KEYS = {\n    backspace: 8,\n    tab: 9,\n    enter: 13,\n    escape: 27,\n    space: 32,\n    up: 38,\n    down: 40,\n    comma: 188\n  };\n\n  function SimplePubSub() {\n    var events = {};\n    return {\n      on: function on(names, handler) {\n        names.split(' ').forEach(function (name) {\n          if (!events[name]) {\n            events[name] = [];\n          }\n          events[name].push(handler);\n        });\n        return this;\n      },\n      trigger: function trigger(name, args) {\n        angular.forEach(events[name], function (handler) {\n          handler.call(null, args);\n        });\n        return this;\n      }\n    };\n  }\n\n  function makeObjectArray(array, key, key2) {\n    array = array || [];\n    if (array.length > 0 && !angular.isObject(array[0])) {\n      array.forEach(function (item, index) {\n        array[index] = _defineProperty({}, key, item);\n        if (key2) array[index][key2] = item;\n      });\n    }\n    return array;\n  }\n\n  function findInObjectArray(array, obj, key) {\n    var item = null;\n    var i = 0;\n    var l = array.length;\n\n    if (_.isFunction(key)) {\n      var objVal = key(obj);\n      if (!objVal) return null;\n      for (; i < l; i++) {\n        if (objVal === key(array[i])) {\n          item = array[i];\n          break;\n        }\n      }\n    } else {\n      for (; i < l; i++) {\n        // I'm aware of the internationalization issues regarding toLowerCase()\n        // but I couldn't come up with a better solution right now\n        if (_.has(obj, key) && _.has(array[i], key) && (angular.toJson(array[i][key]) + '').toLowerCase() === (angular.toJson(obj[key]) + '').toLowerCase()) {\n          item = array[i];\n          break;\n        }\n      }\n    }\n    return item;\n  }\n\n  function replaceAll(str, substr, newSubstr) {\n    var expression = substr.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n    return str.replace(new RegExp(expression, 'gi'), newSubstr);\n  }\n\n  function matchTagsWithModel(tags, model, valueProperty) {\n    //if(tags.length !== model.length) return false;\n    if (!model || !tags || !tags.length) return false;\n\n    if (!_.isArray(model)) {\n      if (valueProperty) return angular.equals(model, tags[0][valueProperty]);\n      return angular.equals(model, tags[0]);\n    }\n\n    return tags.some(function (tag, i) {\n      tag = _.isObject(tag) && valueProperty ? tag[valueProperty] : tag;\n      return angular.equals(tag, model[i]);\n    });\n  }\n\n  function selectAll(input) {\n    if (input.value) {\n      input.setSelectionRange(0, input.value.length);\n    }\n  }\n\n  var tagsInput = angular.module('cnTagsInput', []);\n\n  /**\n   * @ngdoc directive\n   * @name tagsInput\n   * @module cnTagsInput\n   *\n   * @description\n   * Renders an input box with tag editing support.\n   *\n   * @param {string} ngModel Assignable angular expression to data-bind to.\n   * @param {string=} [displayProperty=text] Property to be rendered as the tag label.\n   * @param {string=} [valueProperty=value] Property to be used as the value when modelType is not array/object.\n   * @param {number=} tabindex Tab order of the control.\n   * @param {string=} [placeholder=Add a tag] Placeholder text for the control.\n   * @param {number=} [minLength=3] Minimum length for a new tag.\n   * @param {number=} maxLength Maximum length allowed for a new tag.\n   * @param {boolean=} required Sets required validation error key.\n   * @param {number=} minTags Sets minTags validation error key if the number of tags added is less than minTags.\n   * @param {number=} maxTags Sets maxTags validation error key if the number of tags added is greater than maxTags.\n   * @param {boolean=} [allowLeftoverText=false] Sets leftoverText validation error key if there is any leftover text in\n   *                                             the input element when the directive loses focus.\n   * @param {string=} [removeTagSymbol=×] Symbol character for the remove tag button.\n   * @param {boolean=} [addOnEnter=true] Flag indicating that a new tag will be added on pressing the ENTER key.\n   * @param {boolean=} [addOnSpace=false] Flag indicating that a new tag will be added on pressing the SPACE key.\n   * @param {boolean=} [addOnComma=true] Flag indicating that a new tag will be added on pressing the COMMA key.\n   * @param {boolean=} [addOnBlur=true] Flag indicating that a new tag will be added when the input field loses focus.\n   * @param {boolean=} [replaceSpacesWithDashes=false] Flag indicating that spaces will be replaced with dashes.\n   * @param {string=} [allowedTagsPattern=.+] Regular expression that determines whether a new tag is valid.\n   * @param {boolean=} [enableEditingLastTag=false] Flag indicating that the last tag will be moved back into\n   *                                                the new tag input box instead of being removed when the backspace key\n   *                                                is pressed and the input box is empty.\n   * @param {boolean=} [addFromAutocompleteOnly=false] Flag indicating that only tags coming from the autocomplete list will be allowed.\n   *                                                   When this flag is true, addOnEnter, addOnComma, addOnSpace, addOnBlur and\n   *                                                   allowLeftoverText values are ignored.\n   * @param {expression} onBeforeTagAdded Expression to evaluate upon adding a new tag. The new tag is available as $tag.\n   * @param {expression} onBeforeTagRemoved Expression to evaluate upon removing an existing tag. The removed tag is available as $tag.\n   * @param {expression} onBeforeTagChanged Expression to evaluate upon adding or removing a tag. The affected tag is available as $tag. Prev value avialble as $prev.\n   * @param {expression} onTagAdded Expression to evaluate upon adding a new tag. The new tag is available as $tag.\n   * @param {expression} onTagRemoved Expression to evaluate upon removing an existing tag. The removed tag is available as $tag.\n   * @param {expression} onTagChanged Expression to evaluate upon adding or removing a tag. The affected tag is available as $tag. Prev value avialble as $prev.\n   * @param {expression} onInit Expression to evaluate upon initializing model value.\n   * @param {string} modelType Defines ngModel type, if anything other than array, model is set to first tag in list\n   * @param {string} arrayValueType Defines ngModel[] type, if anything other than object, value is set mapped from object's values\n   * @param {boolean=} [hideTags=false] Flag indicating whether to hide tag list (for manually displaying tag list in other way)\n   * @param {boolean=} [dropdown=false] Flag to show icon on right side\n   * @param {string=} [tagsStyle='tags'] Default tags style\n   */\n  tagsInput.directive('tagsInput', [\"$timeout\", \"$document\", \"tagsInputConfig\", \"$sce\", \"$rootScope\", function ($timeout, $document, tagsInputConfig, $sce, $rootScope) {\n    function TagList(options, events) {\n      var self = {},\n          getTagText,\n          setTagText,\n          tagIsValid;\n\n      //getTagText = function(tag) {\n      //  if(!_.isObject(tag)) return tag;\n      //  return tag[options.displayProperty];\n      //};\n\n      getTagText = options.getTagText = function (tag) {\n        if (!_.isObject(tag)) return tag;\n        return options.itemFormatter ? options.itemFormatter(tag) : tag[options.displayProperty];\n      };\n\n      setTagText = function setTagText(tag, text) {\n        // only create tag object when not adding from auto-complete\n        if (tag[options.displayProperty]) return;\n\n        tag[options.displayProperty] = text;\n        if (options.valueProperty && !_.has(tag, options.valueProperty)) {\n          tag[options.valueProperty] = text;\n        }\n      };\n\n      tagIsValid = function tagIsValid(tag) {\n        var tagText = getTagText(tag) + '';\n\n        return (!options.minLength || tagText.length >= options.minLength) && (!options.maxLength || tagText.length <= options.maxLength) && options.allowedTagsPattern.test(tagText) && !findInObjectArray(self.items, tag,\n        //_.has(tag, options.valueProperty) ? options.valueProperty : getTagText\n        options.valueProperty || getTagText);\n      };\n\n      self.items = [];\n\n      self.addText = function (text) {\n        var tag = {};\n        setTagText(tag, text);\n        self.add(tag);\n      };\n\n      self.add = function (tag) {\n        if (tag.disabled) return;\n\n        var tagText = getTagText(tag);\n\n        if (tagText.trim) tagText = tagText.trim();\n\n        if (options.replaceSpacesWithDashes) {\n          tagText = tagText.replace(/\\s/g, '-');\n        }\n\n        setTagText(tag, tagText);\n\n        //console.log('tagIsValid(tag):', tagIsValid(tag));\n        if (tagIsValid(tag)) {\n          //console.log('tag:', tag, options.maxTags, self.items.length >= options.maxTags);\n          if (options.maxTags && self.items.length >= options.maxTags) {\n            self.items.pop();\n            events.trigger('tag-removed', { $tag: tag, $event: 'tag-removed' });\n          }\n          self.items.push(tag);\n          events.trigger('tag-added', { $tag: tag, $event: 'tag-added' });\n        } else {\n          events.trigger('invalid-tag', { $tag: tag, $event: 'invalid-tag' });\n        }\n\n        return tag;\n      };\n\n      self.remove = function (index) {\n        var tag = self.items.splice(index, 1)[0];\n        events.trigger('tag-removed', { $tag: tag, $event: 'tag-removed' });\n        return tag;\n      };\n\n      self.removeLast = function () {\n        var tag,\n            lastTagIndex = self.items.length - 1;\n\n        if (options.enableEditingLastTag || self.selected) {\n          self.selected = null;\n          tag = self.remove(lastTagIndex);\n        } else if (!self.selected) {\n          self.selected = self.items[lastTagIndex];\n        }\n\n        return tag;\n      };\n\n      return self;\n    }\n\n    return {\n      restrict: 'E',\n      require: 'ngModel',\n      scope: {\n        tags: '=ngModel',\n        itemFormatter: '=',\n        ngDisabled: '=',\n        onBeforeTagAdded: '&',\n        onBeforeTagRemoved: '&',\n        onBeforeTagChanged: '&',\n        onTagAdded: '&',\n        onTagRemoved: '&',\n        onTagChanged: '&',\n        onInit: '&',\n        newTag: '=?'\n      },\n      replace: false,\n      transclude: true,\n      templateUrl: 'cnTagsInput/tags-input.html',\n      controller: [\"$scope\", \"$attrs\", \"$element\", function ($scope, $attrs, $element) {\n        tagsInputConfig.load('tagsInput', $scope, $attrs, {\n          placeholder: [String, ''],\n          tabindex: [Number],\n          removeTagSymbol: [String, String.fromCharCode(215)],\n          replaceSpacesWithDashes: [Boolean, false],\n          minLength: [Number, 2],\n          maxLength: [Number],\n          addOnEnter: [Boolean, true],\n          addOnSpace: [Boolean, false],\n          addOnComma: [Boolean, true],\n          addOnBlur: [Boolean, false],\n          allowedTagsPattern: [RegExp, /.+/],\n          enableEditingLastTag: [Boolean, false],\n          required: [Boolean, false],\n          minTags: [Number],\n          maxTags: [Number],\n          displayProperty: [String, 'text'],\n          valueProperty: [String],\n          allowLeftoverText: [Boolean, false],\n          addFromAutocompleteOnly: [Boolean, false],\n          //tagClasses: [Object, null],\n          tagClass: [String, ''],\n          modelType: [String, 'array'],\n          arrayValueType: [String, 'object'],\n          hideTags: [Boolean, false],\n          dropdown: [Boolean, false],\n          tagsStyle: [String, 'tags'],\n          allowBulk: [Boolean, false],\n          bulkDelimiter: [RegExp, /, ?|\\n/],\n          bulkPlaceholder: [String, 'Enter a list separated by commas or new lines'],\n          showButton: [Boolean, false]\n        });\n\n        var options = $scope.options;\n\n        if (!options.valueProperty && (!/object|array/.test(options.modelType) || options.arrayValueType !== 'object')) {\n          options.valueProperty = 'value';\n        }\n\n        if ($scope.itemFormatter) options.itemFormatter = $scope.itemFormatter;\n\n        if (options.tagsStyle === 'tags') {\n          options.tagClass = options.tagClass || 'label-primary';\n        }\n\n        if (options.allowBulk && (options.modelType !== 'array' || options.maxTags === 1)) {\n          options.allowBulk = false;\n        }\n\n        $scope.events = new SimplePubSub();\n        $scope.tagList = new TagList(options, $scope.events);\n\n        this.registerAutocomplete = function () {\n          var input = options.input = $element.find('input.input');\n          input.on('keydown', function (e) {\n            $scope.events.trigger('input-keydown', e);\n          });\n\n          return {\n            addTag: function addTag(tag) {\n              return $scope.tagList.add(tag);\n            },\n            focusInput: function focusInput() {\n              input[0].focus();\n            },\n            blurInput: function blurInput() {\n              input[0].blur();\n            },\n            getTags: function getTags() {\n              return $scope.tagList.items;\n            },\n            getOptions: function getOptions() {\n              return options;\n            },\n            on: function on(name, handler) {\n              $scope.events.on(name, handler);\n              return this;\n            },\n            registerProcessBulk: function registerProcessBulk(fn) {\n              $scope.processBulk = function () {\n                fn($scope.bulkTags).then(function () {\n                  $scope.showBulk = false;\n                  $scope.bulkTags = '';\n                });\n              };\n            }\n          };\n        };\n      }],\n      link: function link(scope, element, attrs, ngModelCtrl) {\n        var hotkeys = [KEYS.enter, KEYS.comma, KEYS.space, KEYS.backspace],\n            tagList = scope.tagList,\n            events = scope.events,\n            options = scope.options,\n            input = element.find('input.input'),\n            blurTimeout;\n\n        if (attrs.inputId && !ngModelCtrl.$name) {\n          ngModelCtrl.$name = attrs.inputId;\n        }\n\n        // before callbacks allow code to modify tag before it's added\n        // after callback fired after ngModel has chance to update\n        function beforeAndAfter(before, after) {\n          return function () {\n            var args = arguments;\n            before.apply(this, args);\n            $timeout(function () {\n              after.apply(this, args);\n            });\n          };\n        }\n\n        events.on('tag-added', beforeAndAfter(scope.onBeforeTagAdded, scope.onTagAdded)).on('tag-removed', beforeAndAfter(scope.onBeforeTagRemoved, scope.onTagRemoved)).on('tag-changed', beforeAndAfter(scope.onBeforeTagChanged, scope.onTagChanged)).on('tag-init', scope.onInit).on('tag-added tag-removed', function (e) {\n          if (!options.maxTags || options.maxTags > scope.tagList.items.length) {\n            selectAll(options.input[0]);\n          } else {\n            scope.newTag.text = '';\n          }\n          if (options.modelType === 'array') {\n            //console.log('options.arrayValueType:', options.arrayValueType);\n            //if(options.arrayValueType === 'object') {\n            if (!options.valueProperty) {\n              scope.tags = scope.tagList.items;\n            } else {\n              scope.tags = _.pluck(scope.tagList.items, options.valueProperty);\n              console.log('scope.tags:', scope.tags);\n            }\n          } else {\n            if (e.$event === 'tag-removed') {\n              //ngModelCtrl.$setViewValue(undefined);\n              scope.tags = undefined;\n            } else {\n              //if(options.modelType === 'object') {\n              if (!options.valueProperty) {\n                //ngModelCtrl.$setViewValue(e.$tag);\n                scope.tags = e.$tag;\n              } else {\n                //ngModelCtrl.$setViewValue(e.$tag.value);\n                scope.tags = _.has(e.$tag, options.valueProperty) ? e.$tag[options.valueProperty] : e.$tag[options.displayProperty];\n              }\n              //scope.tags = [e.$tag];\n            }\n          }\n        }).on('invalid-tag', function () {\n          scope.newTag.invalid = true;\n        }).on('input-change', function () {\n          tagList.selected = null;\n          scope.newTag.invalid = null;\n        }).on('input-focus', function () {\n          ngModelCtrl.$setValidity('leftoverText', true);\n        }).on('input-blur', function () {\n          if (!options.addFromAutocompleteOnly) {\n            if (options.addOnBlur && scope.newTag.text) {\n              tagList.addText(scope.newTag.text);\n            }\n\n            ngModelCtrl.$setValidity('leftoverText', options.allowLeftoverText ? true : !scope.newTag.text);\n          }\n        });\n\n        scope.newTag = { text: '', invalid: null };\n\n        scope.getDisplayText = scope.itemFormatter || function (tag) {\n          return tag && ((tag[options.displayProperty] || 'undefined') + '').trim();\n        };\n\n        scope.getDisplayHtml = function (tag) {\n          return $sce.trustAsHtml(scope.getDisplayText(tag));\n        };\n\n        scope.track = function (tag) {\n          return tag[options.displayProperty];\n        };\n\n        scope.newTagChange = function () {\n          events.trigger('input-change', scope.newTag.text);\n        };\n\n        scope.processBulk = scope.processBulk || function () {\n          var tags = scope.bulkTags.split(options.bulkDelimiter);\n          _.each(tags, function (text) {\n            var tag = {};\n            tag[options.displayProperty] = text;\n            scope.tagList.add(tag);\n          });\n          scope.showBulk = false;\n          scope.bulkTags = '';\n        };\n\n        var first = true;\n\n        scope.triggerInit = function (value, prev) {\n          var criteria = options.valueProperty ? _defineProperty({}, options.valueProperty, value) : value;\n          if (!tagList.items.length || !_.find(tagList.items, criteria)) {\n            events.trigger('tag-init', {\n              $tag: value,\n              $prev: prev,\n              $event: 'tag-init',\n              $setter: function $setter(val) {\n                if (val && !_.isObject(val)) {\n                  var _ref2;\n\n                  tagList.items = [(_ref2 = {}, _defineProperty(_ref2, options.displayProperty, val), _defineProperty(_ref2, options.valueProperty, val), _ref2)];\n                } else {\n                  tagList.items = _.isArray(val) ? val : [val];\n                }\n                return tagList.items;\n              }\n            });\n          }\n        };\n\n        scope.$watch('tags', function (value, prev) {\n          //console.log('tags watch:', value, prev);\n          var changed = !angular.equals(value, prev);\n          var init = !changed && first;\n\n          if (init) {\n            scope.triggerInit(value, prev);\n          }\n          if (changed) {\n            events.trigger('tag-changed', {\n              $tag: value,\n              $prev: prev,\n              $event: 'tag-changed'\n            });\n          }\n\n          if (options.modelType === 'array') {\n            if (_.isArray(value)) {\n              if (value.length) {\n                var match = matchTagsWithModel(tagList.items, scope.tags, options.valueProperty);\n                if (!match) {\n                  scope.triggerInit(value, prev);\n                }\n                if (!match || tagList.items.length !== scope.tags.length) {\n                  tagList.items = makeObjectArray(value, options.displayProperty, options.valueProperty);\n                  if (options.arrayValueType !== 'object') {\n                    scope.tags = _.pluck(tagList.items, options.valueProperty);\n\n                    //console.log('first, init:', first, init, scope.tags);\n                    return;\n                  }\n                }\n              } else {\n                tagList.items = [];\n                if (angular.isUndefined(prev)) return;\n              }\n            } else if (value === undefined) {\n              tagList.items = [];\n              scope.tags = [];\n              return;\n            }\n          } else if (angular.isDefined(value)) {\n            if (_.isArray(value)) {\n              if (value.length) {\n                //if(options.modelType === 'object') {\n                if (!options.valueProperty) {\n                  scope.tags = value[0];\n                } else {\n                  scope.tags = value[0][options.valueProperty];\n                }\n\n                return;\n              } else {\n                scope.tags = undefined;\n              }\n            } else {\n              if (options.modelType === 'object') {\n                if (value !== null) tagList.items = [value];\n              } else {\n                if (_.isObject(value)) {\n                  tagList.items = [value];\n\n                  var val = value[options.valueProperty];\n                  if (!val) val = value[options.displayProperty];\n                  scope.tags = val;\n\n                  return;\n                } else {\n                  if (value && !tagList.items.length) {\n                    scope.triggerInit(value, prev);\n                  }\n                }\n                //else {\n                //  var val = _.first(_.pluck(tagList.items, options.valueProperty));\n                //  if(!val && val !== 0) val = _.first(_.pluck(tagList.items, options.displayProperty));\n                //  if(val !== value) {\n                //    var newTag = {};\n                //    newTag[options.valueProperty] = value;\n                //    tagList.items = [];\n                //  }\n                // todo: why were we overriding scope.tags? This will lead to recursion\n                //console.log('val:', val);\n                //scope.tags = val;\n                //}\n              }\n            }\n          } else if (!value && tagList.items.length) {\n              tagList.items = [];\n            }\n\n          if (!init && changed) {\n            ngModelCtrl.$setDirty();\n          }\n\n          // hack because schemaForm is incorrectly invalidating model sometimes\n          ngModelCtrl.$setValidity('schemaForm', true);\n          if (options.modelType === 'array') {\n            ngModelCtrl.$setValidity('tv4-401', value && options.maxTags ? value.length <= options.maxTags : true);\n            ngModelCtrl.$setValidity('tv4-302', value ? angular.isDefined(options.minTags) ? value.length >= options.minTags : true : false);\n          } else {\n            ngModelCtrl.$setValidity('tv4-302', !options.required || !angular.isUndefined(value));\n          }\n\n          first = false;\n        }, true);\n\n        input.on('keydown', function (e) {\n          // This hack is needed because jqLite doesn't implement stopImmediatePropagation properly.\n          // I've sent a PR to Angular addressing this issue and hopefully it'll be fixed soon.\n          // https://github.com/angular/angular.js/pull/4833\n          if (e.isImmediatePropagationStopped && e.isImmediatePropagationStopped()) {\n            return;\n          }\n\n          var key = e.keyCode,\n              isModifier = e.shiftKey || e.altKey || e.ctrlKey || e.metaKey,\n              addKeys = {},\n              shouldAdd,\n              shouldRemove;\n\n          if (isModifier || hotkeys.indexOf(key) === -1) {\n            return;\n          }\n\n          addKeys[KEYS.enter] = options.addOnEnter;\n          addKeys[KEYS.comma] = options.addOnComma;\n          addKeys[KEYS.space] = options.addOnSpace;\n\n          shouldAdd = !options.addFromAutocompleteOnly && addKeys[key];\n          shouldRemove = !shouldAdd && key === KEYS.backspace && scope.newTag.text.length === 0;\n\n          if (shouldAdd) {\n            tagList.addText(scope.newTag.text);\n\n            scope.$apply();\n            e.preventDefault();\n          } else if (shouldRemove) {\n            var tag = tagList.removeLast();\n            if (tag && options.enableEditingLastTag) {\n              scope.newTag.text = tag[options.displayProperty];\n            }\n\n            scope.$apply();\n            e.preventDefault();\n          }\n        }).on('focus', onFocus).on('blur', function (e) {\n          blurTimeout = $timeout(function () {\n            var activeElement = $document.prop('activeElement'),\n                lostFocusToBrowserWindow = activeElement === input[0],\n                lostFocusToChildElement = element[0].contains(activeElement);\n\n            if (lostFocusToBrowserWindow || !lostFocusToChildElement) {\n              scope.hasFocus = false;\n              events.trigger('input-blur', e);\n            }\n          }, 150); // timeout so that click event triggers first\n        });\n\n        element.find('textarea').on('keydown', function (e) {\n          if (!e.altKey && !e.ctrlKey && !e.metaKey && e.keyCode === KEYS.enter) {\n            e.preventDefault();\n            scope.processBulk();\n          }\n        });\n\n        element.find('div').on('click', function (e) {\n          if (!$(e.target).closest('.suggestion').length) {\n            e.preventDefault();\n            input[0].focus();\n          }\n        });\n\n        function onFocus(e) {\n          if (e) e.preventDefault();\n          if (scope.ngDisabled) return;\n\n          selectAll(e.target);\n\n          if (blurTimeout) $timeout.cancel(blurTimeout);\n\n          scope.hasFocus = true;\n          //console.log('onFocus:', input.val());\n          events.trigger('input-focus', input.val());\n\n          if (!/apply|digest/.test(scope.$root.$$phase)) scope.$apply();\n        }\n      }\n    };\n  }]);\n\n  /**\n   * @ngdoc directive\n   * @name autoComplete\n   * @module cnTagsInput\n   *\n   * @description\n   * Provides autocomplete support for the tagsInput directive.\n   *\n   * @param {expression} source Expression to evaluate upon changing the input content. The input value is available as\n   *                            $query. The result of the expression must be a promise that eventually resolves to an\n   *                            array of strings.\n   * @param {number=} [debounceDelay=100] Amount of time, in milliseconds, to wait before evaluating the expression in\n   *                                      the source option after the last keystroke.\n   * @param {number=} [minLength=3] Minimum number of characters that must be entered before evaluating the expression\n   *                                 in the source option.\n   * @param {boolean=} [highlightMatchedText=true] Flag indicating that the matched text will be highlighted in the\n   *                                               suggestions list.\n   * @param {number=} [maxResultsToShow=10] Maximum number of results to be displayed at a time.\n   */\n  tagsInput.directive('autoComplete', [\"$document\", \"$timeout\", \"$filter\", \"$sce\", \"tagsInputConfig\", \"$parse\", 'Api', function ($document, $timeout, $filter, $sce, tagsInputConfig, $parse, Api) {\n    function SuggestionList(scope, options) {\n      var self = {},\n          debouncedLoadId,\n          getDifference,\n          lastPromise,\n          groupList,\n          splitListItems,\n          formatItemText,\n          mapIndexes;\n\n      groupList = function groupList(list, groupBy) {\n        var filtered = {},\n            map = [],\n            index = 0,\n            keys;\n\n        // loop through each item in the list\n        _.each(list, function (item) {\n          keys = $parse(groupBy)(item);\n          if (!_.isArray(keys)) keys = [keys];\n          _.each(keys, function (key) {\n            if (!filtered[key]) {\n              filtered[key] = [];\n            }\n            filtered[key].push(item);\n          });\n        });\n\n        _.each(filtered, function (group) {\n          group.indexes = [];\n          _.each(group, function (item) {\n            group.indexes.push(index++);\n            map.push(item);\n          });\n        });\n\n        return {\n          groups: filtered,\n          map: map\n        };\n      };\n\n      formatItemText = function formatItemText(item, formatter) {\n        if (formatter) {\n          if (!_.isArray(formatter)) {\n            formatter = [formatter, {}];\n          }\n          return $parse(formatter[0])((formatter[1].val = item) && formatter[1]);\n        }\n\n        return item;\n      };\n\n      splitListItems = function splitListItems(items) {\n        var keys = [];\n\n        function addItem(key, item, group, prop) {\n          var text = _.isObject(item) ? item[prop || options.tagsInput.displayProperty] : item,\n              toAdd = {\n            text: formatItemText(text, group.formatter),\n            value: text,\n            key: key,\n            childKey: prop /*,\n                           tagClass: options.tagClasses && options.tagClasses[key] || options.tagClass*/\n          };\n\n          if (!_.find(group.items, toAdd)) {\n            group.items.push(toAdd);\n          }\n        }\n\n        _.each(scope.searchKeys, function (group) {\n          var key = group.key;\n          group.items = [];\n\n          _.each(items, function (item) {\n            if (item[key]) {\n              if (_.isArray(item[key])) {\n                _.each(item[key], function (child) {\n                  addItem(key, child, group, group.childKey);\n                });\n              } else {\n                addItem(key, item[key], group, group.childKey);\n              }\n            }\n          });\n          keys.push(group);\n        });\n\n        return keys;\n      };\n\n      mapIndexes = function mapIndexes(items) {\n        var map = [],\n            index = 0;\n\n        _.each(items, function (group) {\n          group.indexes = [];\n          _.each(group.items, function (item) {\n            group.indexes.push(index++);\n            map.push(item);\n          });\n        });\n\n        return map;\n      };\n\n      getDifference = function getDifference(array1, array2) {\n        //console.log('getDifference:', array1, array2);\n        if (!array2.length) {\n          return array1.filter(function (item) {\n            return item[options.tagsInput.displayProperty] !== '';\n          });\n        }\n        return array1.filter(function (item) {\n          return !findInObjectArray(array2, item,\n          //_.has(item, options.tagsInput.valueProperty) ? options.tagsInput.valueProperty : options.tagsInput.getTagText\n          options.tagsInput.valueProperty || options.tagsInput.getTagText);\n        });\n      };\n\n      self.reset = function () {\n        lastPromise = null;\n\n        self.items = [];\n        self.visible = false;\n        self.index = -1;\n        self.selected = null;\n        self.query = null;\n\n        $timeout.cancel(debouncedLoadId);\n      };\n\n      self.show = function () {\n        self.selected = null;\n        self.visible = true;\n        self.select(0);\n      };\n\n      self.load = function (query, tags) {\n        if (query.length < options.minLength) {\n          self.reset();\n          return;\n        }\n\n        var promise,\n\n        //filterBy = {},\n        filterBy = query,\n            groups,\n            processItems = function processItems(items) {\n          if (promise && promise !== lastPromise) {\n            return;\n          }\n\n          if (scope.searchKeys) {\n            scope.isGroups = true;\n            //filterBy = query;\n            items = splitListItems(items);\n          }\n          if (_.isObject(items) && !_.isArray(items)) {\n            scope.isGroups = true;\n            items = _.map(items, function (list, group) {\n              return {\n                items: list,\n                label: group\n              };\n            });\n          }\n          if (scope.isGroups) {\n            _.each(items, function (group) {\n              group.items = getDifference(group.items, tags);\n              if (query) group.items = $filter('cnFilter')(group.items, filterBy);\n\n              group.items = group.items.slice(0, options.maxResultsToShow);\n            });\n            self.itemMap = mapIndexes(items);\n          } else {\n            //filterBy[options.tagsInput.displayProperty] = query;\n            items = makeObjectArray(items.data || items, options.tagsInput.displayProperty);\n            items = getDifference(items, tags);\n            //console.log('options.skipFiltering:', options.skipFiltering);\n            if (query && !options.skipFiltering) {\n              items = $filter('cnFilter')(items, filterBy);\n            }\n\n            items = items.slice(0, options.maxResultsToShow);\n\n            if (options.groupBy) {\n              groups = groupList(items, options.groupBy);\n              items = groups.groups;\n              self.itemMap = groups.map;\n            }\n          }\n\n          self.items = items;\n\n          if (!_.isEmpty(self.items)) {\n            self.show();\n          } else {\n            self.reset();\n          }\n        };\n\n        $timeout.cancel(debouncedLoadId);\n        self.query = query;\n        debouncedLoadId = $timeout(function () {\n          var source = scope.source({ $query: query });\n          if (_.isArray(source)) {\n            $timeout(function () {\n              processItems(source || []);\n            });\n          } else {\n            if (!options.minLength) {\n              source.then(function (results) {\n                scope.source = function () {\n                  return results;\n                };\n                processItems(results || []);\n              });\n            } else {\n              promise = source;\n              lastPromise = promise;\n              promise.then(processItems);\n            }\n          }\n        }, options.minLength ? options.debounceDelay : 0, false);\n      };\n      self.selectNext = function () {\n        self.select(++self.index);\n      };\n      self.selectPrior = function () {\n        self.select(--self.index);\n      };\n      self.select = function (index) {\n        var list = self.itemMap || self.items;\n        if (index < 0) {\n          index = list.length - 1;\n        } else if (index >= list.length) {\n          index = 0;\n        }\n        self.index = index;\n        if (self.itemMap) {\n          self.selected = self.itemMap[index];\n        } else {\n          self.selected = self.items[index];\n        }\n      };\n\n      //self.reset();\n\n      return self;\n    }\n\n    function encodeHTML(value) {\n      return value ? value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') : '';\n    }\n\n    return {\n      restrict: 'E',\n      require: '^tagsInput',\n      scope: {\n        source: '&',\n        searchKeys: '=?'\n      },\n      templateUrl: function templateUrl(elem, attrs) {\n        return attrs.customTemplateUrl || 'cnTagsInput/auto-complete.html';\n      },\n      link: function link(scope, element, attrs, tagsInputCtrl) {\n        var hotkeys = [KEYS.enter, KEYS.tab, KEYS.escape, KEYS.up, KEYS.down],\n            suggestionList,\n            tagsInput,\n            options,\n            getItemText,\n            documentClick;\n\n        tagsInputConfig.load('autoComplete', scope, attrs, {\n          debounceDelay: [Number, 1000],\n          minLength: [Number, 3],\n          highlightMatchedText: [Boolean, true],\n          maxResultsToShow: [Number, 75],\n          groupBy: [String, ''],\n          skipFiltering: [Boolean, false]\n        });\n\n        options = scope.options;\n\n        tagsInput = tagsInputCtrl.registerAutocomplete();\n        options.tagsInput = tagsInput.getOptions();\n\n        if (options.minLength === 0 /* && _.isArray(scope.source())*/) {\n            options.tagsInput.dropdown = true;\n            if (options.tagsInput.maxTags === 1) {\n              options.tagsInput.dropdownStyle = 'caret';\n            } else {\n              options.tagsInput.dropdownStyle = 'fa fa-plus';\n            }\n          } else {\n          options.tagsInput.dropdownStyle = 'fa fa-search';\n        }\n\n        suggestionList = new SuggestionList(scope, options);\n\n        getItemText = options.tagsInput.itemFormatter || function (item) {\n          return String(item[options.tagsInput.displayProperty]);\n        };\n\n        scope.suggestionList = suggestionList;\n\n        scope.addSuggestion = function (e) {\n          //console.log('addSuggestion:', e);\n          e.preventDefault();\n\n          //selectAll(e.target);\n\n          var added = false;\n\n          if (suggestionList.selected) {\n            tagsInput.addTag(suggestionList.selected);\n\n            if (!options.tagsInput.maxTags || tagsInput.getTags().length < options.tagsInput.maxTags) {\n              var i = suggestionList.items.indexOf(suggestionList.selected);\n              suggestionList.items.splice(i, 1);\n              suggestionList.select(i);\n              tagsInput.focusInput();\n            } else {\n              suggestionList.reset();\n              tagsInput.blurInput();\n            }\n\n            added = true;\n          }\n          return added;\n        };\n\n        scope.highlight = function (item, key) {\n          var text = getItemText(item, key);\n          //text = encodeHTML(text);\n          if (suggestionList.query && options.highlightMatchedText) {\n            //text = replaceAll(text, encodeHTML(suggestionList.query), '<b>$&</b>');\n            text = replaceAll(text, suggestionList.query, '<b>$&</b>');\n          }\n          return $sce.trustAsHtml('<a>' + text + '</a>');\n        };\n\n        scope.track = function (item, key) {\n          return getItemText(item, key);\n        };\n\n        tagsInput.registerProcessBulk(function (bulkTags) {\n          console.log('autoCompleteProcessBulk:', bulkTags);\n\n          var tags = bulkTags.split(options.tagsInput.bulkDelimiter);\n\n          var addTags = function addTags(i) {\n            return function (data) {\n              _.times(i, function (i) {\n                if (data[i]) tagsInput.addTag(data[i]);\n              });\n            };\n          };\n\n          // in case a query is involved...doesn't hurt to use even if not\n          return Api.batch(function () {\n            for (var i = 0, l = tags.length; i < l; i++) {\n              if (options.tagsInput.maxTags && tagsInput.getTags().length >= options.tagsInput.maxTags) break;\n              var tag = tags[i];\n              var times = 1;\n              var multiple = tags[i].match(/(.*) ?\\((\\d+)\\)$/);\n\n              if (multiple) {\n                tag = multiple[1];\n                times = parseInt(multiple[2]);\n              }\n\n              var results = scope.source({ $query: tag });\n\n              if (_.isArray(results)) {\n                if (results.length) {\n                  if (!options.skipFiltering) {\n                    //var filterBy = {};\n                    var filterBy = tag;\n                    //filterBy[options.tagsInput.displayProperty] = tags[i];\n                    results = $filter('cnFilter')(results, filterBy);\n                  }\n                  addTags(times)(results);\n                } else if (!options.tagsInput.addFromAutocompleteOnly) {\n                  var _tagsInput$addTag;\n\n                  tagsInput.addTag((_tagsInput$addTag = {}, _defineProperty(_tagsInput$addTag, options.tagsInput.displayProperty, tag), _defineProperty(_tagsInput$addTag, options.tagsInput.valueProperty, tag), _tagsInput$addTag));\n                }\n              } else if (results.then) {\n                results.then(addTags(times));\n              }\n            }\n          });\n        });\n\n        tagsInput.on('input-change', function (value) {\n          if (value || !options.minLength) {\n            suggestionList.load(value, tagsInput.getTags());\n          } else {\n            suggestionList.reset();\n          }\n        }).on('input-focus', function (value) {\n          //console.log('input-focus:', options.minLength, suggestionList.visible);\n          if (!suggestionList.visible && !options.minLength) {\n            suggestionList.load(value, tagsInput.getTags());\n          }\n        }).on('input-keydown', function (e) {\n          var key, handled;\n\n          if (hotkeys.indexOf(e.keyCode) === -1) {\n            return;\n          }\n\n          // This hack is needed because jqLite doesn't implement stopImmediatePropagation properly.\n          // I've sent a PR to Angular addressing this issue and hopefully it'll be fixed soon.\n          // https://github.com/angular/angular.js/pull/4833\n          var immediatePropagationStopped = false;\n          e.stopImmediatePropagation = function () {\n            immediatePropagationStopped = true;\n            e.stopPropagation();\n          };\n          e.isImmediatePropagationStopped = function () {\n            return immediatePropagationStopped;\n          };\n\n          if (suggestionList.visible) {\n            key = e.keyCode;\n            handled = false;\n\n            if (key === KEYS.down) {\n              suggestionList.selectNext();\n              handled = true;\n            } else if (key === KEYS.up) {\n              suggestionList.selectPrior();\n              handled = true;\n            } else if (key === KEYS.escape) {\n              suggestionList.reset();\n              handled = true;\n            } else if (key === KEYS.enter) {\n              handled = scope.addSuggestion(e);\n            }\n            // adding seems to prevent tab action, need to figure out a way around that before uncommenting\n            //else if(key === KEYS.tab && options.tagsInput.addOnBlur) {\n            //  scope.addSuggestion(e);\n            //}\n\n            if (handled) {\n              e.preventDefault();\n              e.stopImmediatePropagation();\n              scope.$apply();\n            }\n          }\n        }).on('input-blur', function (e) {\n          //changed to use document click or focus, as this fires too soon and cancels\n          //automcomplete click events\n          //suggestionList.reset();\n        });\n\n        documentClick = function documentClick(e) {\n          if (e.isDefaultPrevented()) return;\n\n          if (suggestionList.visible) {\n            // if autocomplete option was selected, or click/focus triggered outside of directive\n            if (($(e.target).closest('.suggestion').length || !$(e.target).closest(element[0]).length) && !(e.type === 'focusin' && !/^(input|select|textarea|button|a)$/i.test(e.target.tagName))) {\n              suggestionList.reset();\n              if (!/apply|digest/.test(scope.$root.$$phase)) scope.$apply();\n            }\n          }\n        };\n\n        $document.on('click focusin', documentClick);\n\n        scope.$on('$destroy', function () {\n          $document.off('click focusin', documentClick);\n        });\n      }\n    };\n  }]);\n\n  /**\n   * @ngdoc directive\n   * @name tiTranscludeAppend\n   * @module cnTagsInput\n   *\n   * @description\n   * Re-creates the old behavior of ng-transclude. Used internally by tagsInput directive.\n   */\n  tagsInput.directive('tiTranscludeAppend', function () {\n    return function (scope, element, attrs, ctrl, transcludeFn) {\n      transcludeFn(function (clone) {\n        element.append(clone);\n      });\n    };\n  });\n\n  /**\n   * @ngdoc directive\n   * @name tiAutosize\n   * @module cnTagsInput\n   *\n   * @description\n   * Automatically sets the input's width so its content is always visible. Used internally by tagsInput directive.\n   */\n  tagsInput.directive('tiAutosize', function () {\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      link: function link(scope, element, attrs, ctrl) {\n        var THRESHOLD = 3,\n            span,\n            resize;\n\n        span = angular.element('<span class=\"input\"></span>');\n        span.css('display', 'none').css('visibility', 'hidden').css('width', 'auto').css('white-space', 'pre');\n\n        element.parent().append(span);\n\n        resize = function resize(originalValue) {\n          var value = originalValue,\n              width;\n\n          if (angular.isString(value) && value.length === 0) {\n            value = attrs.placeholder;\n          }\n\n          if (value) {\n            span.text(value);\n            span.css('display', '');\n            width = span.prop('offsetWidth');\n            span.css('display', 'none');\n          }\n\n          element.css('width', width ? width + THRESHOLD + 'px' : '');\n\n          return originalValue;\n        };\n\n        ctrl.$parsers.unshift(resize);\n        ctrl.$formatters.unshift(resize);\n\n        attrs.$observe('placeholder', function (value) {\n          if (!ctrl.$modelValue) {\n            resize(value);\n          }\n        });\n      }\n    };\n  });\n\n  /**\n   * @ngdoc service\n   * @name tagsInputConfig\n   * @module cnTagsInput\n   *\n   * @description\n   * Sets global configuration settings for both tagsInput and autoComplete directives. It's also used internally to parse and\n   * initialize options from HTML attributes.\n   */\n  tagsInput.provider('tagsInputConfig', function () {\n    var globalDefaults = {},\n        interpolationStatus = {};\n\n    /**\n     * @ngdoc method\n     * @name setDefaults\n     * @description Sets the default configuration option for a directive.\n     * @methodOf tagsInputConfig\n     *\n     * @param {string} directive Name of the directive to be configured. Must be either 'tagsInput' or 'autoComplete'.\n     * @param {object} defaults Object containing options and their values.\n     *\n     * @returns {object} The service itself for chaining purposes.\n     */\n    this.setDefaults = function (directive, defaults) {\n      globalDefaults[directive] = defaults;\n      return this;\n    };\n\n    /***\n     * @ngdoc method\n     * @name setActiveInterpolation\n     * @description Sets active interpolation for a set of options.\n     * @methodOf tagsInputConfig\n     *\n     * @param {string} directive Name of the directive to be configured. Must be either 'tagsInput' or 'autoComplete'.\n     * @param {object} options Object containing which options should have interpolation turned on at all times.\n     *\n     * @returns {object} The service itself for chaining purposes.\n     */\n    this.setActiveInterpolation = function (directive, options) {\n      interpolationStatus[directive] = options;\n      return this;\n    };\n\n    this.$get = [\"$interpolate\", function ($interpolate) {\n      var converters = {};\n      converters[String] = function (value) {\n        return value;\n      };\n      converters[Number] = function (value) {\n        return parseInt(value, 10);\n      };\n      converters[Boolean] = function (value) {\n        return value.toLowerCase() === 'true';\n      };\n      converters[RegExp] = function (value) {\n        return new RegExp(value);\n      };\n      converters[Object] = function (value) {\n        return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' ? value : Object(value);\n      };\n\n      return {\n        load: function load(directive, scope, attrs, options) {\n          scope.options = {};\n          scope.attrs = attrs;\n          scope.uid = _.uniqueId();\n\n          angular.forEach(options, function (value, key) {\n            var type, localDefault, converter, getDefault, updateValue;\n\n            type = value[0];\n            localDefault = value[1];\n            converter = converters[type];\n\n            getDefault = function getDefault() {\n              var globalValue = globalDefaults[directive] && globalDefaults[directive][key];\n              return angular.isDefined(globalValue) ? globalValue : localDefault;\n            };\n\n            updateValue = function updateValue(value) {\n              scope.options[key] = value ? converter(value) : getDefault();\n            };\n\n            if (scope[key]) {\n              updateValue(scope[key]);\n            } else if (interpolationStatus[directive] && interpolationStatus[directive][key]) {\n              attrs.$observe(key, function (value) {\n                updateValue(value);\n              });\n            } else {\n              updateValue(attrs[key] && $interpolate(attrs[key])(scope.$parent));\n            }\n          });\n        }\n      };\n    }];\n  });\n\n  /* HTML templates */\n  tagsInput.run([\"$templateCache\", function ($templateCache) {\n    $templateCache.put('cnTagsInput/tags-input.html', \"\\\n        <ul class=\\\"list-group cn-autocomplete-list\\\" \\\n            ng-if=\\\"options.tagsStyle === 'list' && tagList.items.length && !options.hideTags\\\">\\\n          <li class=\\\"list-group-item {{options.tagClass}}\\\" \\\n              ng-repeat=\\\"tag in tagList.items\\\" \\\n              ng-class=\\\"{ selected: tag == tagList.selected }\\\">\\\n            <button ng-if=\\\"!ngDisabled\\\" \\\n                    ng-click=\\\"tagList.remove($index)\\\" \\\n                    type=\\\"button\\\" class=\\\"close pull-right\\\">\\\n              <span>&times;</span>\\\n            </button>\\\n            <span class=\\\"tag-item\\\" ng-bind-html=\\\"getDisplayHtml(tag)\\\"/> \\\n          </li>\\\n        </ul>\\\n        <div class=\\\"host clearfix\\\"\\\n             ng-hide=\\\"showBulk\\\"\\\n             ti-transclude-append=\\\"\\\">\\\n          <!-- hack to avoid browser's autocomplete -->\\\n          <input class=\\\"offscreen\\\" \\\n                 id=\\\"fake-{{attrs.id && attrs.id}}-input\\\" \\\n                 name=\\\"fake-{{attrs.id && attrs.id}}-input\\\">\\\n          <!-- end hack to avoid browser's autocomplete -->\\\n          <div class=\\\"input form-control tags\\\" \\\n               ng-class=\\\"{focused: hasFocus}\\\" \\\n               ng-disabled=\\\"ngDisabled\\\">\\\n            <input class=\\\"input\\\" \\\n                   ng-disabled=\\\"ngDisabled\\\"\\\n                   id=\\\"{{attrs.inputId || attrs.id && attrs.id + '-input-' + uid}}\\\"\\\n                   name=\\\"{{attrs.inputId || attrs.id && attrs.id + '-input-' + uid}}\\\"\\\n                   placeholder=\\\"{{options.placeholder}}\\\" \\\n                   tabindex=\\\"{{options.tabindex}}\\\" \\\n                   ng-model=\\\"newTag.text\\\" \\\n                   ng-model-options=\\\"{updateOn: 'default'}\\\" \\\n                   ng-change=\\\"newTagChange()\\\" \\\n                   ng-trim=\\\"false\\\" \\\n                   ng-class=\\\"{\\\n                      'invalid-tag': newTag.invalid,\\\n                      'hide-below': options.maxTags === 1 && tagList.items.length\\\n                   }\\\" \\\n                   ti-autosize=\\\"\\\"\\\n                   autocomplete=\\\"off\\\">\\\n            <span class=\\\"tag-item label {{options.tagClass}} label-block\\\"\\\n                  ng-if=\\\"options.tagsStyle !== 'list' && !options.hideTags && options.maxTags === 1 && tagList.items.length\\\"\\\n                  title=\\\"{{getDisplayText(tagList.items[0])}}\\\">\\\n              <span ng-bind-html=\\\"getDisplayHtml(tagList.items[0])\\\"/> \\\n              <a class=\\\"remove-button\\\" \\\n                 ng-if=\\\"!ngDisabled && !options.dropdown\\\"\\\n                 ng-click=\\\"tagList.remove()\\\">\\\n                <span>&times;</span>\\\n              </a>\\\n            </span>\\\n            <ul class=\\\"tag-list\\\" \\\n                ng-if=\\\"options.tagsStyle !== 'list' && !options.hideTags && options.maxTags !== 1\\\">\\\n              <li class=\\\"tag-item label {{options.tagClass}}\\\" \\\n                  ng-repeat=\\\"tag in tagList.items\\\" \\\n                  ng-class=\\\"{ selected: tag == tagList.selected }\\\">\\\n                <span ng-bind-html=\\\"getDisplayHtml(tag)\\\"/> \\\n                <a class=\\\"remove-button\\\" \\\n                   ng-if=\\\"!ngDisabled\\\"\\\n                   ng-click=\\\"tagList.remove($index)\\\">\\\n                  <span>&times;</span>\\\n                </a>\\\n              </li>\\\n            </ul>\\\n            <button ng-if=\\\"options.showButton && options.dropdown\\\"\\\n                    class=\\\"btn form-control-icon\\\" ng-disabled=\\\"ngDisabled\\\" tabindex=\\\"-1\\\">\\\n              <i class=\\\"{{options.dropdownStyle}}\\\"></i>\\\n            </button>\\\n          </div>\\\n        </div>\\\n        <p class=\\\"help-block\\\" ng-show=\\\"options.allowBulk && !showBulk\\\"><a ng-click=\\\"showBulk = true\\\">Batch mode</a></p>\\\n        <div ng-show=\\\"showBulk\\\" class=\\\"clearfix\\\">\\\n          <textarea class=\\\"form-control\\\" ng-model=\\\"bulkTags\\\" placeholder=\\\"{{options.bulkPlaceholder}}\\\"></textarea>\\\n          <p class=\\\"help-block\\\">\\\n            Press \\\"Enter\\\" to submit, or return to <a ng-show=\\\"options.allowBulk\\\" ng-click=\\\"showBulk = false\\\">browse mode</a>\\\n          </p>\\\n        </div>\");\n\n    $templateCache.put('cnTagsInput/auto-complete.html', \"<div ng-if=\\\"!suggestionList.items.length && !options.groupBy\\\" \\\n             ng-class=\\\"{open: suggestionList.visible}\\\">\\\n          <ul class=\\\"autocomplete dropdown-menu\\\">\\\n            <li class=\\\"dropdown-header\\\">No items...</li>\\\n          </ul>\\\n        </div>\\\n        <div ng-if=\\\"suggestionList.items.length && isGroups\\\" \\\n             ng-class=\\\"{open: suggestionList.visible}\\\">\\\n          <ul class=\\\"autocomplete dropdown-menu\\\">\\\n            <li ng-repeat-start=\\\"group in suggestionList.items\\\"></li>\\\n            <li class=\\\"dropdown-header\\\" ng-show=\\\"group.items.length\\\">{{group.label | titleCase}}</li>\\\n            <li ng-repeat=\\\"item in group.items\\\" \\\n                class=\\\"suggestion\\\" \\\n                ng-class=\\\"{selected: item == suggestionList.selected, disabled: item.disabled}\\\" \\\n                ng-click=\\\"addSuggestion($event)\\\" \\\n                ng-mouseenter=\\\"suggestionList.select(group.indexes[$index])\\\" \\\n                ng-bind-html=\\\"highlight(item, group.label)\\\">\\\n            </li>\\\n            <li class=\\\"divider\\\" ng-show=\\\"!$last && $parent.suggestionList.items[$index+1].items.length\\\"></li>\\\n            <li ng-repeat-end></li>\\\n          </ul>\\\n        </div>\\\n        <div ng-if=\\\"suggestionList.items.length && !isGroups && !options.groupBy\\\" \\\n             ng-class=\\\"{open: suggestionList.visible}\\\">\\\n          <ul class=\\\"autocomplete dropdown-menu\\\">\\\n            <li ng-repeat=\\\"item in suggestionList.items\\\" \\\n                class=\\\"suggestion\\\" \\\n                ng-class=\\\"{selected: item == suggestionList.selected, disabled: item.disabled}\\\" \\\n                ng-click=\\\"addSuggestion($event)\\\" \\\n                ng-mouseenter=\\\"suggestionList.select($index)\\\" \\\n                ng-bind-html=\\\"highlight(item)\\\">\\\n            </li>\\\n          </ul>\\\n        </div>\\\n        <div ng-if=\\\"!isGroups && options.groupBy\\\" \\\n             ng-class=\\\"{open: suggestionList.visible}\\\">\\\n          <ul class=\\\"autocomplete dropdown-menu\\\">\\\n            <li ng-repeat-start=\\\"(group, items) in suggestionList.items\\\"></li>\\\n            <li class=\\\"dropdown-header\\\" ng-show=\\\"items.length\\\">{{group | titleCase}}</li>\\\n            <li ng-repeat=\\\"item in items\\\" \\\n                class=\\\"suggestion\\\" \\\n                ng-class=\\\"{selected: item == suggestionList.selected, disabled: item.disabled}\\\" \\\n                ng-click=\\\"addSuggestion($event)\\\" \\\n                ng-mouseenter=\\\"suggestionList.select(suggestionList.items[group].indexes[$index])\\\" \\\n                ng-bind-html=\\\"highlight(item)\\\">\\\n            </li>\\\n            <li class=\\\"divider\\\" ng-show=\\\"!$last && items.length\\\"></li>\\\n            <li ng-repeat-end></li>\\\n          </ul>\\\n        </div>\");\n  }]);\n})();","/*!\n * ngTagsInput v2.0.1\n * http://mbenford.github.io/ngTagsInput\n *\n * Copyright (c) 2013-2014 Michael Benford\n * License: MIT\n *\n * Generated at 2014-04-13 21:25:38 -0300\n */\n(function() {\n  'use strict';\n\n  var KEYS = {\n    backspace: 8,\n    tab: 9,\n    enter: 13,\n    escape: 27,\n    space: 32,\n    up: 38,\n    down: 40,\n    comma: 188\n  };\n\n  function SimplePubSub() {\n    var events = {};\n    return {\n      on: function(names, handler) {\n        names.split(' ').forEach(function(name) {\n          if(!events[name]) {\n            events[name] = [];\n          }\n          events[name].push(handler);\n        });\n        return this;\n      },\n      trigger: function(name, args) {\n        angular.forEach(events[name], function(handler) {\n          handler.call(null, args);\n        });\n        return this;\n      }\n    };\n  }\n\n  function makeObjectArray(array, key, key2) {\n    array = array || [];\n    if(array.length > 0 && !angular.isObject(array[0])) {\n      array.forEach(function(item, index) {\n        array[index] = {\n          [key]: item\n        };\n        if(key2) array[index][key2] = item;\n      });\n    }\n    return array;\n  }\n\n  function findInObjectArray(array, obj, key) {\n    var item = null;\n    var i = 0;\n    var l = array.length;\n\n    if(_.isFunction(key)) {\n      var objVal = key(obj);\n      if(!objVal) return null;\n      for(; i < l; i++) {\n        if(objVal === key(array[i])) {\n          item = array[i];\n          break;\n        }\n      }\n    }\n    else {\n      for(; i < l; i++) {\n        // I'm aware of the internationalization issues regarding toLowerCase()\n        // but I couldn't come up with a better solution right now\n        if(_.has(obj, key) &&\n            _.has(array[i], key) &&\n            (angular.toJson(array[i][key]) + '').toLowerCase() === (angular.toJson(obj[key]) + '').toLowerCase()) {\n          item = array[i];\n          break;\n        }\n      }\n    }\n    return item;\n  }\n\n  function replaceAll(str, substr, newSubstr) {\n    var expression = substr.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n    return str.replace(new RegExp(expression, 'gi'), newSubstr);\n  }\n\n  function matchTagsWithModel(tags, model, valueProperty) {\n    //if(tags.length !== model.length) return false;\n    if(!model || !tags || !tags.length) return false;\n\n    if(!_.isArray(model)) {\n      if(valueProperty) return angular.equals(model, tags[0][valueProperty]);\n      return angular.equals(model, tags[0]);\n    }\n\n    return tags.some((tag, i) => {\n      tag = (_.isObject(tag) && valueProperty) ? tag[valueProperty] : tag;\n      return angular.equals(tag, model[i]);\n    });\n  }\n\n  function selectAll(input) {\n    if(input.value) {\n      input.setSelectionRange(0, input.value.length);\n    }\n  }\n\n  var tagsInput = angular.module('cnTagsInput', []);\n\n  /**\n   * @ngdoc directive\n   * @name tagsInput\n   * @module cnTagsInput\n   *\n   * @description\n   * Renders an input box with tag editing support.\n   *\n   * @param {string} ngModel Assignable angular expression to data-bind to.\n   * @param {string=} [displayProperty=text] Property to be rendered as the tag label.\n   * @param {string=} [valueProperty=value] Property to be used as the value when modelType is not array/object.\n   * @param {number=} tabindex Tab order of the control.\n   * @param {string=} [placeholder=Add a tag] Placeholder text for the control.\n   * @param {number=} [minLength=3] Minimum length for a new tag.\n   * @param {number=} maxLength Maximum length allowed for a new tag.\n   * @param {boolean=} required Sets required validation error key.\n   * @param {number=} minTags Sets minTags validation error key if the number of tags added is less than minTags.\n   * @param {number=} maxTags Sets maxTags validation error key if the number of tags added is greater than maxTags.\n   * @param {boolean=} [allowLeftoverText=false] Sets leftoverText validation error key if there is any leftover text in\n   *                                             the input element when the directive loses focus.\n   * @param {string=} [removeTagSymbol=×] Symbol character for the remove tag button.\n   * @param {boolean=} [addOnEnter=true] Flag indicating that a new tag will be added on pressing the ENTER key.\n   * @param {boolean=} [addOnSpace=false] Flag indicating that a new tag will be added on pressing the SPACE key.\n   * @param {boolean=} [addOnComma=true] Flag indicating that a new tag will be added on pressing the COMMA key.\n   * @param {boolean=} [addOnBlur=true] Flag indicating that a new tag will be added when the input field loses focus.\n   * @param {boolean=} [replaceSpacesWithDashes=false] Flag indicating that spaces will be replaced with dashes.\n   * @param {string=} [allowedTagsPattern=.+] Regular expression that determines whether a new tag is valid.\n   * @param {boolean=} [enableEditingLastTag=false] Flag indicating that the last tag will be moved back into\n   *                                                the new tag input box instead of being removed when the backspace key\n   *                                                is pressed and the input box is empty.\n   * @param {boolean=} [addFromAutocompleteOnly=false] Flag indicating that only tags coming from the autocomplete list will be allowed.\n   *                                                   When this flag is true, addOnEnter, addOnComma, addOnSpace, addOnBlur and\n   *                                                   allowLeftoverText values are ignored.\n   * @param {expression} onBeforeTagAdded Expression to evaluate upon adding a new tag. The new tag is available as $tag.\n   * @param {expression} onBeforeTagRemoved Expression to evaluate upon removing an existing tag. The removed tag is available as $tag.\n   * @param {expression} onBeforeTagChanged Expression to evaluate upon adding or removing a tag. The affected tag is available as $tag. Prev value avialble as $prev.\n   * @param {expression} onTagAdded Expression to evaluate upon adding a new tag. The new tag is available as $tag.\n   * @param {expression} onTagRemoved Expression to evaluate upon removing an existing tag. The removed tag is available as $tag.\n   * @param {expression} onTagChanged Expression to evaluate upon adding or removing a tag. The affected tag is available as $tag. Prev value avialble as $prev.\n   * @param {expression} onInit Expression to evaluate upon initializing model value.\n   * @param {string} modelType Defines ngModel type, if anything other than array, model is set to first tag in list\n   * @param {string} arrayValueType Defines ngModel[] type, if anything other than object, value is set mapped from object's values\n   * @param {boolean=} [hideTags=false] Flag indicating whether to hide tag list (for manually displaying tag list in other way)\n   * @param {boolean=} [dropdown=false] Flag to show icon on right side\n   * @param {string=} [tagsStyle='tags'] Default tags style\n   */\n  tagsInput.directive('tagsInput', [\n    \"$timeout\", \"$document\", \"tagsInputConfig\", \"$sce\", \"$rootScope\",\n    function($timeout, $document, tagsInputConfig, $sce, $rootScope) {\n      function TagList(options, events) {\n        var self = {}, getTagText, setTagText, tagIsValid;\n\n        //getTagText = function(tag) {\n        //  if(!_.isObject(tag)) return tag;\n        //  return tag[options.displayProperty];\n        //};\n\n        getTagText = options.getTagText = function(tag) {\n          if(!_.isObject(tag)) return tag;\n          return options.itemFormatter ? options.itemFormatter(tag) : tag[options.displayProperty];\n        };\n\n        setTagText = function(tag, text) {\n          // only create tag object when not adding from auto-complete\n          if(tag[options.displayProperty]) return;\n\n          tag[options.displayProperty] = text;\n          if(options.valueProperty && !_.has(tag, options.valueProperty)) {\n            tag[options.valueProperty] = text;\n          }\n        };\n\n        tagIsValid = function(tag) {\n          var tagText = getTagText(tag) + '';\n\n          return (!options.minLength || tagText.length >= options.minLength) &&\n                 (!options.maxLength || tagText.length <= options.maxLength) &&\n                 options.allowedTagsPattern.test(tagText) &&\n                 !findInObjectArray(\n                     self.items,\n                     tag,\n                     //_.has(tag, options.valueProperty) ? options.valueProperty : getTagText\n                     options.valueProperty || getTagText\n                 );\n        };\n\n        self.items = [];\n\n        self.addText = function(text) {\n          var tag = {};\n          setTagText(tag, text);\n          self.add(tag);\n        };\n\n        self.add = function(tag) {\n          if(tag.disabled) return;\n\n          var tagText = getTagText(tag);\n\n          if(tagText.trim) tagText = tagText.trim();\n\n          if(options.replaceSpacesWithDashes) {\n            tagText = tagText.replace(/\\s/g, '-');\n          }\n\n          setTagText(tag, tagText);\n\n          //console.log('tagIsValid(tag):', tagIsValid(tag));\n          if(tagIsValid(tag)) {\n            //console.log('tag:', tag, options.maxTags, self.items.length >= options.maxTags);\n            if(options.maxTags && self.items.length >= options.maxTags) {\n              self.items.pop();\n              events.trigger('tag-removed', {$tag: tag, $event: 'tag-removed'});\n            }\n            self.items.push(tag);\n            events.trigger('tag-added', {$tag: tag, $event: 'tag-added'});\n          }\n          else {\n            events.trigger('invalid-tag', {$tag: tag, $event: 'invalid-tag'});\n          }\n\n          return tag;\n        };\n\n        self.remove = function(index) {\n          var tag = self.items.splice(index, 1)[0];\n          events.trigger('tag-removed', {$tag: tag, $event: 'tag-removed'});\n          return tag;\n        };\n\n        self.removeLast = function() {\n          var tag, lastTagIndex = self.items.length - 1;\n\n          if(options.enableEditingLastTag || self.selected) {\n            self.selected = null;\n            tag = self.remove(lastTagIndex);\n          }\n          else if(!self.selected) {\n            self.selected = self.items[lastTagIndex];\n          }\n\n          return tag;\n        };\n\n        return self;\n      }\n\n      return {\n        restrict: 'E',\n        require: 'ngModel',\n        scope: {\n          tags: '=ngModel',\n          itemFormatter: '=',\n          ngDisabled: '=',\n          onBeforeTagAdded: '&',\n          onBeforeTagRemoved: '&',\n          onBeforeTagChanged: '&',\n          onTagAdded: '&',\n          onTagRemoved: '&',\n          onTagChanged: '&',\n          onInit: '&',\n          newTag: '=?'\n        },\n        replace: false,\n        transclude: true,\n        templateUrl: 'cnTagsInput/tags-input.html',\n        controller: [\"$scope\", \"$attrs\", \"$element\", function($scope, $attrs, $element) {\n          tagsInputConfig.load('tagsInput', $scope, $attrs, {\n            placeholder: [String, ''],\n            tabindex: [Number],\n            removeTagSymbol: [String, String.fromCharCode(215)],\n            replaceSpacesWithDashes: [Boolean, false],\n            minLength: [Number, 2],\n            maxLength: [Number],\n            addOnEnter: [Boolean, true],\n            addOnSpace: [Boolean, false],\n            addOnComma: [Boolean, true],\n            addOnBlur: [Boolean, false],\n            allowedTagsPattern: [RegExp, /.+/],\n            enableEditingLastTag: [Boolean, false],\n            required: [Boolean, false],\n            minTags: [Number],\n            maxTags: [Number],\n            displayProperty: [String, 'text'],\n            valueProperty: [String],\n            allowLeftoverText: [Boolean, false],\n            addFromAutocompleteOnly: [Boolean, false],\n            //tagClasses: [Object, null],\n            tagClass: [String, ''],\n            modelType: [String, 'array'],\n            arrayValueType: [String, 'object'],\n            hideTags: [Boolean, false],\n            dropdown: [Boolean, false],\n            tagsStyle: [String, 'tags'],\n            allowBulk: [Boolean, false],\n            bulkDelimiter: [RegExp, /, ?|\\n/],\n            bulkPlaceholder: [String, 'Enter a list separated by commas or new lines'],\n            showButton: [Boolean, false]\n          });\n\n          var options = $scope.options;\n\n          if(!options.valueProperty &&\n              (!/object|array/.test(options.modelType) || options.arrayValueType !== 'object')) {\n            options.valueProperty = 'value';\n          }\n\n          if($scope.itemFormatter) options.itemFormatter = $scope.itemFormatter;\n\n          if(options.tagsStyle === 'tags') {\n            options.tagClass = options.tagClass || 'label-primary';\n          }\n\n          if(options.allowBulk && (options.modelType !== 'array' || options.maxTags === 1)) {\n            options.allowBulk = false;\n          }\n\n          $scope.events = new SimplePubSub();\n          $scope.tagList = new TagList(options, $scope.events);\n\n          this.registerAutocomplete = function() {\n            var input = options.input = $element.find('input.input');\n            input.on('keydown', function(e) {\n              $scope.events.trigger('input-keydown', e);\n            });\n\n            return {\n              addTag: function(tag) {\n                return $scope.tagList.add(tag);\n              },\n              focusInput: function() {\n                input[0].focus();\n              },\n              blurInput: function() {\n                input[0].blur();\n              },\n              getTags: function() {\n                return $scope.tagList.items;\n              },\n              getOptions: function() {\n                return options;\n              },\n              on: function(name, handler) {\n                $scope.events.on(name, handler);\n                return this;\n              },\n              registerProcessBulk: function(fn) {\n                $scope.processBulk = function() {\n                  fn($scope.bulkTags).then(function() {\n                    $scope.showBulk = false;\n                    $scope.bulkTags = '';\n                  });\n                };\n              }\n            };\n          };\n        }],\n        link: function(scope, element, attrs, ngModelCtrl) {\n          var hotkeys = [KEYS.enter, KEYS.comma, KEYS.space, KEYS.backspace],\n              tagList = scope.tagList,\n              events = scope.events,\n              options = scope.options,\n              input = element.find('input.input'),\n              blurTimeout;\n\n          if(attrs.inputId && !ngModelCtrl.$name) {\n            ngModelCtrl.$name = attrs.inputId;\n          }\n\n          // before callbacks allow code to modify tag before it's added\n          // after callback fired after ngModel has chance to update\n          function beforeAndAfter(before, after) {\n            return function() {\n              var args = arguments;\n              before.apply(this, args);\n              $timeout(function(){\n                after.apply(this, args);\n              });\n            };\n          }\n\n          events\n              .on('tag-added', beforeAndAfter(scope.onBeforeTagAdded, scope.onTagAdded))\n              .on('tag-removed', beforeAndAfter(scope.onBeforeTagRemoved, scope.onTagRemoved))\n              .on('tag-changed', beforeAndAfter(scope.onBeforeTagChanged, scope.onTagChanged))\n              .on('tag-init', scope.onInit)\n              .on('tag-added tag-removed', function(e) {\n                if(!options.maxTags || options.maxTags > scope.tagList.items.length) {\n                  selectAll(options.input[0]);\n                }\n                else {\n                  scope.newTag.text = '';\n                }\n                if(options.modelType === 'array') {\n                  //console.log('options.arrayValueType:', options.arrayValueType);\n                  //if(options.arrayValueType === 'object') {\n                  if(!options.valueProperty) {\n                    scope.tags = scope.tagList.items;\n                  }\n                  else {\n                    scope.tags = _.pluck(scope.tagList.items, options.valueProperty);\n                    console.log('scope.tags:', scope.tags);\n                  }\n                }\n                else {\n                  if(e.$event === 'tag-removed') {\n                    //ngModelCtrl.$setViewValue(undefined);\n                    scope.tags = undefined;\n                  }\n                  else {\n                    //if(options.modelType === 'object') {\n                    if(!options.valueProperty) {\n                      //ngModelCtrl.$setViewValue(e.$tag);\n                      scope.tags = e.$tag;\n                    }\n                    else {\n                      //ngModelCtrl.$setViewValue(e.$tag.value);\n                      scope.tags = _.has(e.$tag, options.valueProperty) ?\n                          e.$tag[options.valueProperty] : e.$tag[options.displayProperty];\n                    }\n                    //scope.tags = [e.$tag];\n                  }\n                }\n              })\n              .on('invalid-tag', function() {\n                scope.newTag.invalid = true;\n              })\n              .on('input-change', function() {\n                tagList.selected = null;\n                scope.newTag.invalid = null;\n              })\n              .on('input-focus', function() {\n                ngModelCtrl.$setValidity('leftoverText', true);\n              })\n              .on('input-blur', function() {\n                if(!options.addFromAutocompleteOnly) {\n                  if(options.addOnBlur && scope.newTag.text) {\n                    tagList.addText(scope.newTag.text);\n                  }\n\n                  ngModelCtrl.$setValidity('leftoverText', options.allowLeftoverText ? true : !scope.newTag.text);\n                }\n              });\n\n          scope.newTag = {text: '', invalid: null};\n\n          scope.getDisplayText = scope.itemFormatter || function(tag) {\n            return tag && ((tag[options.displayProperty] || 'undefined') + '').trim();\n          };\n\n          scope.getDisplayHtml = function(tag) {\n            return $sce.trustAsHtml(scope.getDisplayText(tag));\n          };\n\n          scope.track = function(tag) {\n            return tag[options.displayProperty];\n          };\n\n          scope.newTagChange = function() {\n            events.trigger('input-change', scope.newTag.text);\n          };\n\n          scope.processBulk = scope.processBulk || function() {\n            var tags = scope.bulkTags.split(options.bulkDelimiter);\n            _.each(tags, function(text) {\n              var tag = {};\n              tag[options.displayProperty] = text;\n              scope.tagList.add(tag);\n            });\n            scope.showBulk = false;\n            scope.bulkTags = '';\n          };\n\n          var first = true;\n\n          scope.triggerInit = function(value, prev) {\n            var criteria = options.valueProperty ? {[options.valueProperty]: value} : value;\n            if(!tagList.items.length || !_.find(tagList.items, criteria)) {\n              events.trigger('tag-init', {\n                $tag: value,\n                $prev: prev,\n                $event: 'tag-init',\n                $setter: function(val) {\n                  if(val && !_.isObject(val)) {\n                    tagList.items = [{\n                      [options.displayProperty]: val,\n                      [options.valueProperty]: val\n                    }];\n                  }\n                  else {\n                    tagList.items = _.isArray(val) ? val : [val];\n                  }\n                  return tagList.items;\n                }\n              });\n            }\n          };\n\n          scope.$watch('tags', function(value, prev) {\n            //console.log('tags watch:', value, prev);\n            var changed = !angular.equals(value, prev);\n            var init    = !changed && first;\n\n            if(init) {\n              scope.triggerInit(value, prev);\n            }\n            if(changed) {\n              events.trigger('tag-changed', {\n                $tag: value,\n                $prev: prev,\n                $event: 'tag-changed'\n              });\n            }\n\n            if(options.modelType === 'array') {\n              if(_.isArray(value)) {\n                if(value.length) {\n                  var match = matchTagsWithModel(tagList.items, scope.tags, options.valueProperty);\n                  if(!match) {\n                    scope.triggerInit(value, prev);\n                  }\n                  if(!match || tagList.items.length !== scope.tags.length) {\n                    tagList.items = makeObjectArray(value, options.displayProperty, options.valueProperty);\n                    if(options.arrayValueType !== 'object') {\n                      scope.tags = _.pluck(tagList.items, options.valueProperty);\n\n                      //console.log('first, init:', first, init, scope.tags);\n                      return;\n                    }\n                  }\n                }\n                else {\n                  tagList.items = [];\n                  if(angular.isUndefined(prev)) return;\n                }\n              }\n              else if(value === undefined) {\n                tagList.items = [];\n                scope.tags = [];\n                return;\n              }\n            }\n            else if(angular.isDefined(value)) {\n              if(_.isArray(value)) {\n                if(value.length) {\n                  //if(options.modelType === 'object') {\n                  if(!options.valueProperty) {\n                    scope.tags = value[0];\n                  }\n                  else {\n                    scope.tags = value[0][options.valueProperty];\n                  }\n\n                  return;\n                }\n                else {\n                  scope.tags = undefined;\n                }\n              }\n              else {\n                if(options.modelType === 'object') {\n                  if(value !== null) tagList.items = [value];\n                }\n                else {\n                  if(_.isObject(value)) {\n                    tagList.items = [value];\n\n                    var val = value[options.valueProperty];\n                    if(!val) val = value[options.displayProperty];\n                    scope.tags = val;\n\n                    return;\n                  }\n                  else {\n                    if(value && !tagList.items.length) {\n                      scope.triggerInit(value, prev);\n                    }\n                  }\n                  //else {\n                  //  var val = _.first(_.pluck(tagList.items, options.valueProperty));\n                  //  if(!val && val !== 0) val = _.first(_.pluck(tagList.items, options.displayProperty));\n                  //  if(val !== value) {\n                  //    var newTag = {};\n                  //    newTag[options.valueProperty] = value;\n                  //    tagList.items = [];\n                  //  }\n                    // todo: why were we overriding scope.tags? This will lead to recursion\n                    //console.log('val:', val);\n                    //scope.tags = val;\n                  //}\n                }\n              }\n            }\n            else if(!value && tagList.items.length) {\n              tagList.items = [];\n            }\n\n            if(!init && changed) {\n              ngModelCtrl.$setDirty();\n            }\n\n            // hack because schemaForm is incorrectly invalidating model sometimes\n            ngModelCtrl.$setValidity('schemaForm', true);\n            if(options.modelType === 'array') {\n              ngModelCtrl.$setValidity('tv4-401', value && options.maxTags ? value.length <= options.maxTags : true);\n              ngModelCtrl.$setValidity('tv4-302', value ? angular.isDefined(options.minTags) ? value.length >= options.minTags : true : false);\n            }\n            else {\n              ngModelCtrl.$setValidity('tv4-302', !options.required || !(angular.isUndefined(value)));\n            }\n\n            first = false;\n\n          }, true);\n\n          input\n              .on('keydown', function(e) {\n                // This hack is needed because jqLite doesn't implement stopImmediatePropagation properly.\n                // I've sent a PR to Angular addressing this issue and hopefully it'll be fixed soon.\n                // https://github.com/angular/angular.js/pull/4833\n                if(e.isImmediatePropagationStopped && e.isImmediatePropagationStopped()) {\n                  return;\n                }\n\n                var key = e.keyCode,\n                    isModifier = e.shiftKey || e.altKey || e.ctrlKey || e.metaKey,\n                    addKeys = {},\n                    shouldAdd, shouldRemove;\n\n                if(isModifier || hotkeys.indexOf(key) === -1) {\n                  return;\n                }\n\n                addKeys[KEYS.enter] = options.addOnEnter;\n                addKeys[KEYS.comma] = options.addOnComma;\n                addKeys[KEYS.space] = options.addOnSpace;\n\n                shouldAdd = !options.addFromAutocompleteOnly && addKeys[key];\n                shouldRemove = !shouldAdd && key === KEYS.backspace && scope.newTag.text.length === 0;\n\n                if(shouldAdd) {\n                  tagList.addText(scope.newTag.text);\n\n                  scope.$apply();\n                  e.preventDefault();\n                }\n                else if(shouldRemove) {\n                  var tag = tagList.removeLast();\n                  if(tag && options.enableEditingLastTag) {\n                    scope.newTag.text = tag[options.displayProperty];\n                  }\n\n                  scope.$apply();\n                  e.preventDefault();\n                }\n              })\n              .on('focus', onFocus)\n              .on('blur', function(e) {\n                blurTimeout = $timeout(function() {\n                  var activeElement = $document.prop('activeElement'),\n                      lostFocusToBrowserWindow = activeElement === input[0],\n                      lostFocusToChildElement = element[0].contains(activeElement);\n\n                  if(lostFocusToBrowserWindow || !lostFocusToChildElement) {\n                    scope.hasFocus = false;\n                    events.trigger('input-blur', e);\n                  }\n                }, 150); // timeout so that click event triggers first\n              });\n\n          element.find('textarea').on('keydown', function(e) {\n            if(!e.altKey && !e.ctrlKey && !e.metaKey && e.keyCode === KEYS.enter) {\n              e.preventDefault();\n              scope.processBulk();\n            }\n          });\n\n          element.find('div').on('click', function(e) {\n            if(!$(e.target).closest('.suggestion').length) {\n              e.preventDefault();\n              input[0].focus();\n            }\n          });\n\n          function onFocus(e) {\n            if(e) e.preventDefault();\n            if(scope.ngDisabled) return;\n\n            selectAll(e.target);\n\n            if(blurTimeout) $timeout.cancel(blurTimeout);\n\n            scope.hasFocus = true;\n            //console.log('onFocus:', input.val());\n            events.trigger('input-focus', input.val());\n\n            if(!/apply|digest/.test(scope.$root.$$phase)) scope.$apply();\n          }\n        }\n      };\n    }]);\n\n  /**\n   * @ngdoc directive\n   * @name autoComplete\n   * @module cnTagsInput\n   *\n   * @description\n   * Provides autocomplete support for the tagsInput directive.\n   *\n   * @param {expression} source Expression to evaluate upon changing the input content. The input value is available as\n   *                            $query. The result of the expression must be a promise that eventually resolves to an\n   *                            array of strings.\n   * @param {number=} [debounceDelay=100] Amount of time, in milliseconds, to wait before evaluating the expression in\n   *                                      the source option after the last keystroke.\n   * @param {number=} [minLength=3] Minimum number of characters that must be entered before evaluating the expression\n   *                                 in the source option.\n   * @param {boolean=} [highlightMatchedText=true] Flag indicating that the matched text will be highlighted in the\n   *                                               suggestions list.\n   * @param {number=} [maxResultsToShow=10] Maximum number of results to be displayed at a time.\n   */\n  tagsInput.directive('autoComplete', [\n    \"$document\", \"$timeout\", \"$filter\", \"$sce\", \"tagsInputConfig\", \"$parse\", 'Api',\n    function($document, $timeout, $filter, $sce, tagsInputConfig, $parse, Api) {\n      function SuggestionList(scope, options) {\n        var self = {}, debouncedLoadId, getDifference, lastPromise, groupList,\n            splitListItems, formatItemText, mapIndexes;\n\n        groupList = function(list, groupBy) {\n          var filtered = {},\n              map = [],\n              index = 0,\n              keys;\n\n          // loop through each item in the list\n          _.each(list, function(item) {\n            keys = $parse(groupBy)(item);\n            if(!_.isArray(keys)) keys = [keys];\n            _.each(keys, function(key) {\n              if(!filtered[key]) {\n                filtered[key] = [];\n              }\n              filtered[key].push(item);\n            });\n          });\n\n          _.each(filtered, function(group) {\n            group.indexes = [];\n            _.each(group, function(item) {\n              group.indexes.push(index++);\n              map.push(item);\n            });\n          });\n\n          return {\n            groups: filtered,\n            map: map\n          };\n        };\n\n        formatItemText = function(item, formatter) {\n          if(formatter) {\n            if(!_.isArray(formatter)) {\n              formatter = [formatter, {}];\n            }\n            return $parse(formatter[0])((formatter[1].val = item) && formatter[1]);\n          }\n\n          return item;\n        };\n\n        splitListItems = function(items) {\n          var keys = [];\n\n          function addItem(key, item, group, prop) {\n            var text = _.isObject(item) ? item[prop || options.tagsInput.displayProperty] : item,\n                toAdd = {\n                  text: formatItemText(text, group.formatter),\n                  value: text,\n                  key: key,\n                  childKey: prop/*,\n                  tagClass: options.tagClasses && options.tagClasses[key] || options.tagClass*/\n                };\n\n            if(!_.find(group.items, toAdd)) {\n              group.items.push(toAdd);\n            }\n          }\n\n          _.each(scope.searchKeys, function(group) {\n            var key = group.key;\n            group.items = [];\n\n            _.each(items, function(item) {\n              if(item[key]) {\n                if(_.isArray(item[key])) {\n                  _.each(item[key], function(child) {\n                    addItem(key, child, group, group.childKey);\n                  });\n                }\n                else {\n                  addItem(key, item[key], group, group.childKey);\n                }\n              }\n            });\n            keys.push(group);\n          });\n\n          return keys;\n        };\n\n        mapIndexes = function(items) {\n          var map = [],\n              index = 0;\n\n          _.each(items, function(group) {\n            group.indexes = [];\n            _.each(group.items, function(item) {\n              group.indexes.push(index++);\n              map.push(item);\n            });\n          });\n\n          return map;\n        };\n\n        getDifference = function(array1, array2) {\n          //console.log('getDifference:', array1, array2);\n          if(!array2.length) {\n            return array1.filter(function(item) {\n              return item[options.tagsInput.displayProperty] !== '';\n            });\n          }\n          return array1.filter(function(item) {\n            return !findInObjectArray(\n                array2,\n                item,\n                //_.has(item, options.tagsInput.valueProperty) ? options.tagsInput.valueProperty : options.tagsInput.getTagText\n                options.tagsInput.valueProperty || options.tagsInput.getTagText\n            );\n          });\n        };\n\n        self.reset = function() {\n          lastPromise = null;\n\n          self.items = [];\n          self.visible = false;\n          self.index = -1;\n          self.selected = null;\n          self.query = null;\n\n          $timeout.cancel(debouncedLoadId);\n        };\n\n        self.show = function() {\n          self.selected = null;\n          self.visible = true;\n          self.select(0);\n        };\n\n        self.load = function(query, tags) {\n          if(query.length < options.minLength) {\n            self.reset();\n            return;\n          }\n\n          var promise,\n              //filterBy = {},\n              filterBy = query,\n              groups,\n              processItems = function(items) {\n                if(promise && promise !== lastPromise) {\n                  return;\n                }\n\n                if(scope.searchKeys) {\n                  scope.isGroups = true;\n                  //filterBy = query;\n                  items = splitListItems(items);\n                }\n                if(_.isObject(items) && !_.isArray(items)) {\n                  scope.isGroups = true;\n                  items = _.map(items, function(list, group) {\n                    return {\n                      items: list,\n                      label: group\n                    };\n                  });\n                }\n                if(scope.isGroups) {\n                  _.each(items, function(group) {\n                    group.items = getDifference(group.items, tags);\n                    if(query) group.items = $filter('cnFilter')(group.items, filterBy);\n\n                    group.items = group.items.slice(0, options.maxResultsToShow);\n                  });\n                  self.itemMap = mapIndexes(items);\n                }\n                else {\n                  //filterBy[options.tagsInput.displayProperty] = query;\n                  items = makeObjectArray(items.data || items, options.tagsInput.displayProperty);\n                  items = getDifference(items, tags);\n                  //console.log('options.skipFiltering:', options.skipFiltering);\n                  if(query && !options.skipFiltering) {\n                    items = $filter('cnFilter')(items, filterBy);\n                  }\n\n                  items = items.slice(0, options.maxResultsToShow);\n\n                  if(options.groupBy) {\n                    groups = groupList(items, options.groupBy);\n                    items = groups.groups;\n                    self.itemMap = groups.map;\n                  }\n                }\n\n                self.items = items;\n\n                if(!_.isEmpty(self.items)) {\n                  self.show();\n                }\n                else {\n                  self.reset();\n                }\n              };\n\n          $timeout.cancel(debouncedLoadId);\n          self.query = query;\n          debouncedLoadId = $timeout(function() {\n            var source = scope.source({$query: query});\n            if(_.isArray(source)) {\n              $timeout(function() {\n                processItems(source || []);\n              });\n            }\n            else {\n              if(!options.minLength) {\n                source.then(function(results) {\n                  scope.source = function() {\n                    return results;\n                  };\n                  processItems(results || []);\n                });\n              }\n              else {\n                promise = source;\n                lastPromise = promise;\n                promise.then(processItems);\n              }\n            }\n          }, options.minLength ? options.debounceDelay : 0, false);\n\n        };\n        self.selectNext = function() {\n          self.select(++self.index);\n        };\n        self.selectPrior = function() {\n          self.select(--self.index);\n        };\n        self.select = function(index) {\n          var list = self.itemMap || self.items;\n          if(index < 0) {\n            index = list.length - 1;\n          }\n          else if(index >= list.length) {\n            index = 0;\n          }\n          self.index = index;\n          if(self.itemMap) {\n            self.selected = self.itemMap[index];\n          }\n          else {\n            self.selected = self.items[index];\n          }\n        };\n\n        //self.reset();\n\n        return self;\n      }\n\n      function encodeHTML(value) {\n        return value ? value\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;') : '';\n      }\n\n      return {\n        restrict: 'E',\n        require: '^tagsInput',\n        scope: {\n          source: '&',\n          searchKeys: '=?'\n        },\n        templateUrl: function(elem, attrs) {\n          return attrs.customTemplateUrl || 'cnTagsInput/auto-complete.html';\n        },\n        link: function(scope, element, attrs, tagsInputCtrl) {\n          var hotkeys = [KEYS.enter, KEYS.tab, KEYS.escape, KEYS.up, KEYS.down],\n              suggestionList, tagsInput, options, getItemText, documentClick;\n\n          tagsInputConfig.load('autoComplete', scope, attrs, {\n            debounceDelay: [Number, 1000],\n            minLength: [Number, 3],\n            highlightMatchedText: [Boolean, true],\n            maxResultsToShow: [Number, 75],\n            groupBy: [String, ''],\n            skipFiltering: [Boolean, false]\n          });\n\n          options = scope.options;\n\n          tagsInput = tagsInputCtrl.registerAutocomplete();\n          options.tagsInput = tagsInput.getOptions();\n\n          if(options.minLength === 0/* && _.isArray(scope.source())*/) {\n            options.tagsInput.dropdown = true;\n            if(options.tagsInput.maxTags === 1) {\n              options.tagsInput.dropdownStyle = 'caret';\n            }\n            else {\n              options.tagsInput.dropdownStyle = 'fa fa-plus';\n            }\n          }\n          else {\n            options.tagsInput.dropdownStyle = 'fa fa-search';\n          }\n\n          suggestionList = new SuggestionList(scope, options);\n\n          getItemText = options.tagsInput.itemFormatter || function(item) {\n            return String(item[options.tagsInput.displayProperty]);\n          };\n\n          scope.suggestionList = suggestionList;\n\n          scope.addSuggestion = function(e) {\n            //console.log('addSuggestion:', e);\n            e.preventDefault();\n\n            //selectAll(e.target);\n\n            var added = false;\n\n            if(suggestionList.selected) {\n              tagsInput.addTag(suggestionList.selected);\n\n              if(!options.tagsInput.maxTags || tagsInput.getTags().length < options.tagsInput.maxTags) {\n                var i = suggestionList.items.indexOf(suggestionList.selected);\n                suggestionList.items.splice(i, 1);\n                suggestionList.select(i);\n                tagsInput.focusInput();\n              }\n              else {\n                suggestionList.reset();\n                tagsInput.blurInput();\n              }\n\n              added = true;\n            }\n            return added;\n          };\n\n          scope.highlight = function(item, key) {\n            var text = getItemText(item, key);\n            //text = encodeHTML(text);\n            if(suggestionList.query && options.highlightMatchedText) {\n              //text = replaceAll(text, encodeHTML(suggestionList.query), '<b>$&</b>');\n              text = replaceAll(text, suggestionList.query, '<b>$&</b>');\n            }\n            return $sce.trustAsHtml('<a>' + text + '</a>');\n          };\n\n          scope.track = function(item, key) {\n            return getItemText(item, key);\n          };\n\n          tagsInput.registerProcessBulk(function(bulkTags) {\n            console.log('autoCompleteProcessBulk:', bulkTags);\n\n            var tags = bulkTags.split(options.tagsInput.bulkDelimiter);\n\n            var addTags = function(i) {\n              return function(data) {\n                _.times(i, function(i) {\n                  if(data[i]) tagsInput.addTag(data[i]);\n                });\n              };\n            };\n\n            // in case a query is involved...doesn't hurt to use even if not\n            return Api.batch(function() {\n              for(var i = 0, l = tags.length; i < l; i++) {\n                if(options.tagsInput.maxTags && tagsInput.getTags().length >= options.tagsInput.maxTags) break;\n                var tag = tags[i];\n                var times = 1;\n                var multiple = tags[i].match(/(.*) ?\\((\\d+)\\)$/);\n\n                if(multiple) {\n                  tag = multiple[1];\n                  times = parseInt(multiple[2]);\n                }\n\n                var results = scope.source({$query: tag});\n\n                if(_.isArray(results)) {\n                  if(results.length) {\n                    if(!options.skipFiltering) {\n                      //var filterBy = {};\n                      var filterBy = tag;\n                      //filterBy[options.tagsInput.displayProperty] = tags[i];\n                      results = $filter('cnFilter')(results, filterBy);\n                    }\n                    addTags(times)(results);\n                  }\n                  else if(!options.tagsInput.addFromAutocompleteOnly) {\n                    tagsInput.addTag({\n                      [options.tagsInput.displayProperty]: tag,\n                      [options.tagsInput.valueProperty]: tag\n                    });\n                  }\n                }\n                else if(results.then) {\n                  results.then(addTags(times));\n                }\n              }\n            });\n          });\n\n          tagsInput\n              .on('input-change', function(value) {\n                if(value || !options.minLength) {\n                  suggestionList.load(value, tagsInput.getTags());\n                }\n                else {\n                  suggestionList.reset();\n                }\n              })\n              .on('input-focus', function(value) {\n                //console.log('input-focus:', options.minLength, suggestionList.visible);\n                if(!suggestionList.visible && !options.minLength) {\n                  suggestionList.load(value, tagsInput.getTags());\n                }\n              })\n              .on('input-keydown', function(e) {\n                var key, handled;\n\n                if(hotkeys.indexOf(e.keyCode) === -1) {\n                  return;\n                }\n\n                // This hack is needed because jqLite doesn't implement stopImmediatePropagation properly.\n                // I've sent a PR to Angular addressing this issue and hopefully it'll be fixed soon.\n                // https://github.com/angular/angular.js/pull/4833\n                var immediatePropagationStopped = false;\n                e.stopImmediatePropagation = function() {\n                  immediatePropagationStopped = true;\n                  e.stopPropagation();\n                };\n                e.isImmediatePropagationStopped = function() {\n                  return immediatePropagationStopped;\n                };\n\n                if(suggestionList.visible) {\n                  key = e.keyCode;\n                  handled = false;\n\n                  if(key === KEYS.down) {\n                    suggestionList.selectNext();\n                    handled = true;\n                  }\n                  else if(key === KEYS.up) {\n                    suggestionList.selectPrior();\n                    handled = true;\n                  }\n                  else if(key === KEYS.escape) {\n                    suggestionList.reset();\n                    handled = true;\n                  }\n                  else if(key === KEYS.enter) {\n                    handled = scope.addSuggestion(e);\n                  }\n                  // adding seems to prevent tab action, need to figure out a way around that before uncommenting\n                  //else if(key === KEYS.tab && options.tagsInput.addOnBlur) {\n                  //  scope.addSuggestion(e);\n                  //}\n\n                  if(handled) {\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    scope.$apply();\n                  }\n                }\n              })\n              .on('input-blur', function(e) {\n                //changed to use document click or focus, as this fires too soon and cancels\n                //automcomplete click events\n                //suggestionList.reset();\n              });\n\n          documentClick = function(e) {\n            if(e.isDefaultPrevented()) return;\n\n            if(suggestionList.visible) {\n              // if autocomplete option was selected, or click/focus triggered outside of directive\n              if(($(e.target).closest('.suggestion').length || !$(e.target).closest(element[0]).length) &&\n                  !(e.type === 'focusin' && !/^(input|select|textarea|button|a)$/i.test(e.target.tagName))) {\n                suggestionList.reset();\n                if(!/apply|digest/.test(scope.$root.$$phase)) scope.$apply();\n              }\n            }\n          };\n\n          $document.on('click focusin', documentClick);\n\n          scope.$on('$destroy', function() {\n            $document.off('click focusin', documentClick);\n          });\n        }\n      };\n    }]);\n\n\n  /**\n   * @ngdoc directive\n   * @name tiTranscludeAppend\n   * @module cnTagsInput\n   *\n   * @description\n   * Re-creates the old behavior of ng-transclude. Used internally by tagsInput directive.\n   */\n  tagsInput.directive('tiTranscludeAppend', function() {\n    return function(scope, element, attrs, ctrl, transcludeFn) {\n      transcludeFn(function(clone) {\n        element.append(clone);\n      });\n    };\n  });\n\n  /**\n   * @ngdoc directive\n   * @name tiAutosize\n   * @module cnTagsInput\n   *\n   * @description\n   * Automatically sets the input's width so its content is always visible. Used internally by tagsInput directive.\n   */\n  tagsInput.directive('tiAutosize', function() {\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      link: function(scope, element, attrs, ctrl) {\n        var THRESHOLD = 3,\n            span, resize;\n\n        span = angular.element('<span class=\"input\"></span>');\n        span.css('display', 'none')\n            .css('visibility', 'hidden')\n            .css('width', 'auto')\n            .css('white-space', 'pre');\n\n        element.parent().append(span);\n\n        resize = function(originalValue) {\n          var value = originalValue, width;\n\n          if(angular.isString(value) && value.length === 0) {\n            value = attrs.placeholder;\n          }\n\n          if(value) {\n            span.text(value);\n            span.css('display', '');\n            width = span.prop('offsetWidth');\n            span.css('display', 'none');\n          }\n\n          element.css('width', width ? width + THRESHOLD + 'px' : '');\n\n          return originalValue;\n        };\n\n        ctrl.$parsers.unshift(resize);\n        ctrl.$formatters.unshift(resize);\n\n        attrs.$observe('placeholder', function(value) {\n          if(!ctrl.$modelValue) {\n            resize(value);\n          }\n        });\n      }\n    };\n  });\n\n  /**\n   * @ngdoc service\n   * @name tagsInputConfig\n   * @module cnTagsInput\n   *\n   * @description\n   * Sets global configuration settings for both tagsInput and autoComplete directives. It's also used internally to parse and\n   * initialize options from HTML attributes.\n   */\n  tagsInput.provider('tagsInputConfig', function() {\n    var globalDefaults = {}, interpolationStatus = {};\n\n    /**\n     * @ngdoc method\n     * @name setDefaults\n     * @description Sets the default configuration option for a directive.\n     * @methodOf tagsInputConfig\n     *\n     * @param {string} directive Name of the directive to be configured. Must be either 'tagsInput' or 'autoComplete'.\n     * @param {object} defaults Object containing options and their values.\n     *\n     * @returns {object} The service itself for chaining purposes.\n     */\n    this.setDefaults = function(directive, defaults) {\n      globalDefaults[directive] = defaults;\n      return this;\n    };\n\n    /***\n     * @ngdoc method\n     * @name setActiveInterpolation\n     * @description Sets active interpolation for a set of options.\n     * @methodOf tagsInputConfig\n     *\n     * @param {string} directive Name of the directive to be configured. Must be either 'tagsInput' or 'autoComplete'.\n     * @param {object} options Object containing which options should have interpolation turned on at all times.\n     *\n     * @returns {object} The service itself for chaining purposes.\n     */\n    this.setActiveInterpolation = function(directive, options) {\n      interpolationStatus[directive] = options;\n      return this;\n    };\n\n    this.$get = [\"$interpolate\", function($interpolate) {\n      var converters = {};\n      converters[String] = function(value) {\n        return value;\n      };\n      converters[Number] = function(value) {\n        return parseInt(value, 10);\n      };\n      converters[Boolean] = function(value) {\n        return value.toLowerCase() === 'true';\n      };\n      converters[RegExp] = function(value) {\n        return new RegExp(value);\n      };\n      converters[Object] = function(value) {\n        return typeof value === 'object' ? value : Object(value);\n      };\n\n      return {\n        load: function(directive, scope, attrs, options) {\n          scope.options = {};\n          scope.attrs = attrs;\n          scope.uid = _.uniqueId();\n\n          angular.forEach(options, function(value, key) {\n            var type, localDefault, converter, getDefault, updateValue;\n\n            type = value[0];\n            localDefault = value[1];\n            converter = converters[type];\n\n            getDefault = function() {\n              var globalValue = globalDefaults[directive] && globalDefaults[directive][key];\n              return angular.isDefined(globalValue) ? globalValue : localDefault;\n            };\n\n            updateValue = function(value) {\n              scope.options[key] = value ? converter(value) : getDefault();\n            };\n\n            if(scope[key]) {\n              updateValue(scope[key]);\n            }\n            else if(interpolationStatus[directive] && interpolationStatus[directive][key]) {\n              attrs.$observe(key, function(value) {\n                updateValue(value);\n              });\n            }\n            else {\n              updateValue(attrs[key] && $interpolate(attrs[key])(scope.$parent));\n            }\n          });\n        }\n      };\n    }];\n  });\n\n\n  /* HTML templates */\n  tagsInput.run([\"$templateCache\", function($templateCache) {\n    $templateCache.put('cnTagsInput/tags-input.html',\n        \"\\\n        <ul class=\\\"list-group cn-autocomplete-list\\\" \\\n            ng-if=\\\"options.tagsStyle === 'list' && tagList.items.length && !options.hideTags\\\">\\\n          <li class=\\\"list-group-item {{options.tagClass}}\\\" \\\n              ng-repeat=\\\"tag in tagList.items\\\" \\\n              ng-class=\\\"{ selected: tag == tagList.selected }\\\">\\\n            <button ng-if=\\\"!ngDisabled\\\" \\\n                    ng-click=\\\"tagList.remove($index)\\\" \\\n                    type=\\\"button\\\" class=\\\"close pull-right\\\">\\\n              <span>&times;</span>\\\n            </button>\\\n            <span class=\\\"tag-item\\\" ng-bind-html=\\\"getDisplayHtml(tag)\\\"/> \\\n          </li>\\\n        </ul>\\\n        <div class=\\\"host clearfix\\\"\\\n             ng-hide=\\\"showBulk\\\"\\\n             ti-transclude-append=\\\"\\\">\\\n          <!-- hack to avoid browser's autocomplete -->\\\n          <input class=\\\"offscreen\\\" \\\n                 id=\\\"fake-{{attrs.id && attrs.id}}-input\\\" \\\n                 name=\\\"fake-{{attrs.id && attrs.id}}-input\\\">\\\n          <!-- end hack to avoid browser's autocomplete -->\\\n          <div class=\\\"input form-control tags\\\" \\\n               ng-class=\\\"{focused: hasFocus}\\\" \\\n               ng-disabled=\\\"ngDisabled\\\">\\\n            <input class=\\\"input\\\" \\\n                   ng-disabled=\\\"ngDisabled\\\"\\\n                   id=\\\"{{attrs.inputId || attrs.id && attrs.id + '-input-' + uid}}\\\"\\\n                   name=\\\"{{attrs.inputId || attrs.id && attrs.id + '-input-' + uid}}\\\"\\\n                   placeholder=\\\"{{options.placeholder}}\\\" \\\n                   tabindex=\\\"{{options.tabindex}}\\\" \\\n                   ng-model=\\\"newTag.text\\\" \\\n                   ng-model-options=\\\"{updateOn: 'default'}\\\" \\\n                   ng-change=\\\"newTagChange()\\\" \\\n                   ng-trim=\\\"false\\\" \\\n                   ng-class=\\\"{\\\n                      'invalid-tag': newTag.invalid,\\\n                      'hide-below': options.maxTags === 1 && tagList.items.length\\\n                   }\\\" \\\n                   ti-autosize=\\\"\\\"\\\n                   autocomplete=\\\"off\\\">\\\n            <span class=\\\"tag-item label {{options.tagClass}} label-block\\\"\\\n                  ng-if=\\\"options.tagsStyle !== 'list' && !options.hideTags && options.maxTags === 1 && tagList.items.length\\\"\\\n                  title=\\\"{{getDisplayText(tagList.items[0])}}\\\">\\\n              <span ng-bind-html=\\\"getDisplayHtml(tagList.items[0])\\\"/> \\\n              <a class=\\\"remove-button\\\" \\\n                 ng-if=\\\"!ngDisabled && !options.dropdown\\\"\\\n                 ng-click=\\\"tagList.remove()\\\">\\\n                <span>&times;</span>\\\n              </a>\\\n            </span>\\\n            <ul class=\\\"tag-list\\\" \\\n                ng-if=\\\"options.tagsStyle !== 'list' && !options.hideTags && options.maxTags !== 1\\\">\\\n              <li class=\\\"tag-item label {{options.tagClass}}\\\" \\\n                  ng-repeat=\\\"tag in tagList.items\\\" \\\n                  ng-class=\\\"{ selected: tag == tagList.selected }\\\">\\\n                <span ng-bind-html=\\\"getDisplayHtml(tag)\\\"/> \\\n                <a class=\\\"remove-button\\\" \\\n                   ng-if=\\\"!ngDisabled\\\"\\\n                   ng-click=\\\"tagList.remove($index)\\\">\\\n                  <span>&times;</span>\\\n                </a>\\\n              </li>\\\n            </ul>\\\n            <button ng-if=\\\"options.showButton && options.dropdown\\\"\\\n                    class=\\\"btn form-control-icon\\\" ng-disabled=\\\"ngDisabled\\\" tabindex=\\\"-1\\\">\\\n              <i class=\\\"{{options.dropdownStyle}}\\\"></i>\\\n            </button>\\\n          </div>\\\n        </div>\\\n        <p class=\\\"help-block\\\" ng-show=\\\"options.allowBulk && !showBulk\\\"><a ng-click=\\\"showBulk = true\\\">Batch mode</a></p>\\\n        <div ng-show=\\\"showBulk\\\" class=\\\"clearfix\\\">\\\n          <textarea class=\\\"form-control\\\" ng-model=\\\"bulkTags\\\" placeholder=\\\"{{options.bulkPlaceholder}}\\\"></textarea>\\\n          <p class=\\\"help-block\\\">\\\n            Press \\\"Enter\\\" to submit, or return to <a ng-show=\\\"options.allowBulk\\\" ng-click=\\\"showBulk = false\\\">browse mode</a>\\\n          </p>\\\n        </div>\"\n    );\n\n    $templateCache.put('cnTagsInput/auto-complete.html',\n        \"<div ng-if=\\\"!suggestionList.items.length && !options.groupBy\\\" \\\n             ng-class=\\\"{open: suggestionList.visible}\\\">\\\n          <ul class=\\\"autocomplete dropdown-menu\\\">\\\n            <li class=\\\"dropdown-header\\\">No items...</li>\\\n          </ul>\\\n        </div>\\\n        <div ng-if=\\\"suggestionList.items.length && isGroups\\\" \\\n             ng-class=\\\"{open: suggestionList.visible}\\\">\\\n          <ul class=\\\"autocomplete dropdown-menu\\\">\\\n            <li ng-repeat-start=\\\"group in suggestionList.items\\\"></li>\\\n            <li class=\\\"dropdown-header\\\" ng-show=\\\"group.items.length\\\">{{group.label | titleCase}}</li>\\\n            <li ng-repeat=\\\"item in group.items\\\" \\\n                class=\\\"suggestion\\\" \\\n                ng-class=\\\"{selected: item == suggestionList.selected, disabled: item.disabled}\\\" \\\n                ng-click=\\\"addSuggestion($event)\\\" \\\n                ng-mouseenter=\\\"suggestionList.select(group.indexes[$index])\\\" \\\n                ng-bind-html=\\\"highlight(item, group.label)\\\">\\\n            </li>\\\n            <li class=\\\"divider\\\" ng-show=\\\"!$last && $parent.suggestionList.items[$index+1].items.length\\\"></li>\\\n            <li ng-repeat-end></li>\\\n          </ul>\\\n        </div>\\\n        <div ng-if=\\\"suggestionList.items.length && !isGroups && !options.groupBy\\\" \\\n             ng-class=\\\"{open: suggestionList.visible}\\\">\\\n          <ul class=\\\"autocomplete dropdown-menu\\\">\\\n            <li ng-repeat=\\\"item in suggestionList.items\\\" \\\n                class=\\\"suggestion\\\" \\\n                ng-class=\\\"{selected: item == suggestionList.selected, disabled: item.disabled}\\\" \\\n                ng-click=\\\"addSuggestion($event)\\\" \\\n                ng-mouseenter=\\\"suggestionList.select($index)\\\" \\\n                ng-bind-html=\\\"highlight(item)\\\">\\\n            </li>\\\n          </ul>\\\n        </div>\\\n        <div ng-if=\\\"!isGroups && options.groupBy\\\" \\\n             ng-class=\\\"{open: suggestionList.visible}\\\">\\\n          <ul class=\\\"autocomplete dropdown-menu\\\">\\\n            <li ng-repeat-start=\\\"(group, items) in suggestionList.items\\\"></li>\\\n            <li class=\\\"dropdown-header\\\" ng-show=\\\"items.length\\\">{{group | titleCase}}</li>\\\n            <li ng-repeat=\\\"item in items\\\" \\\n                class=\\\"suggestion\\\" \\\n                ng-class=\\\"{selected: item == suggestionList.selected, disabled: item.disabled}\\\" \\\n                ng-click=\\\"addSuggestion($event)\\\" \\\n                ng-mouseenter=\\\"suggestionList.select(suggestionList.items[group].indexes[$index])\\\" \\\n                ng-bind-html=\\\"highlight(item)\\\">\\\n            </li>\\\n            <li class=\\\"divider\\\" ng-show=\\\"!$last && items.length\\\"></li>\\\n            <li ng-repeat-end></li>\\\n          </ul>\\\n        </div>\"\n    );\n  }]);\n})();"]}