{"version":3,"sources":["all.js","cn-tags-input.js"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","_typeof","Symbol","iterator","constructor","prototype","empty","_","forOwn","_value","coll","set","SimplePubSub","events","on","names","handler","split","forEach","name","push","this","trigger","args","angular","call","destroy","makeObjectArray","array","key2","length","isObject","item","index","getArrayModelVal","options","arrayValueType","map","valueProperty","pluck","findInObjectArray","i","l","isFunction","objVal","has","toJson","toLowerCase","replaceAll","str","substr","newSubstr","expression","replace","RegExp","matchTagsWithModel","tags","model","isArray","equals","some","tag","findTagsForValue","matches","filter","find","val","matchTag","addFromAutocompleteOnly","each","v","m","modelType","tagValue","objectContains","small","large","every","selectAll","input","setSelectionRange","sortResults","results","displayProperty","valueFor","first","remove","result","startsWith","sortBy","reTag","second","test","search","third","concat","copyToClipboard","text","isString","copyElement","document","createElement","style","position","opacity","textContent","body","getElementsByTagName","appendChild","select","execCommand","removeChild","stripHtml","html","tmp","innerHTML","innerText","KEYS","backspace","tab","enter","escape","space","up","down","comma","tagsInput","module","directive","$timeout","$document","tagsInputConfig","$sce","$rootScope","TagList","getTagText","setTagText","tagIsValid","self","itemFormatter","tagText","minLength","maxLength","allowedTagsPattern","items","addText","add","disabled","trim","replaceSpacesWithDashes","maxTags","pop","$tag","$event","splice","removeLast","lastTagIndex","enableEditingLastTag","selected","removeAll","e","preventDefault","copyAllToClipboard","join","restrict","require","scope","ngDisabled","onBeforeTagAdded","onBeforeTagRemoved","onBeforeTagChanged","onTagAdded","onTagRemoved","onTagChanged","onInit","newTag","transclude","templateUrl","controller","$scope","$attrs","$element","handleKeydown","load","placeholder","String","tabindex","Number","removeTagSymbol","fromCharCode","Boolean","addOnEnter","addOnSpace","addOnComma","addOnBlur","clearOnBlur","required","minTags","allowLeftoverText","tagClass","hideTags","dropdownIcon","tagsStyle","allowBulk","bulkSingleRequest","bulkDelimiter","bulkPlaceholder","sortFilteredResults","showClearAll","showClearCache","showButton","$on","off","tagList","processBulk","registerAutocomplete","addTag","focusInput","focus","blurInput","blur","getTags","getModel","getOptions","registerProcessBulk","fn","bulkTags","then","showBulk","registerSuggestionList","suggestionList","link","element","attrs","ngModelCtrl","tagsInputTag","beforeAndAfter","before","after","arguments","apply","inlineChangeTags","newTags","isObjectArray","handleInputKeydown","isImmediatePropagationStopped","shouldAdd","shouldRemove","keyCode","isModifier","shiftKey","altKey","ctrlKey","metaKey","addKeys","hotkeys","indexOf","$apply","handleInputBlur","blurTimeout","activeElement","prop","lostFocusToBrowserWindow","lostFocusToChildElement","contains","hasFocus","handleInputFocus","target","cancel","$root","$$phase","handleTextareaKeydown","handleDivClick","$target","$","closest","parent","hasClass","__tag","textarea","div","inputId","$name","$setValidity","undefined","invalid","getDisplayText","getDisplayHtml","trustAsHtml","handleShowTooltip","outerWidth","offsetParent","width","fadeIn","handleHideTooltip","fadeOut","track","newTagChange","triggerInit","prev","criteria","$prev","$setter","_ref2","$watch","changed","init","isUndefined","isDefined","$setDirty","uglyHackTimeout","$filter","$parse","Api","$q","SuggestionList","debouncedLoadId","getDifference","lastPromise","groupList","splitListItems","formatItemText","mapIndexes","list","groupBy","keys","filtered","group","indexes","groups","formatter","addItem","toAdd","childKey","searchKeys","child","array1","array2","reset","visible","query","show","promise","filterBy","processItems","isGroups","label","reconciliateItems","idx","__uniqueid","uniqueId","cloneDeep","ref","slice","maxResultsToShow","itemMap","data","skipFiltering","_load","debounceDelay","clearCache","event","_source","source","$query","refreshData","d","defer","resolve","selectNext","selectPrior","elem","customTemplateUrl","tagsInputCtrl","autoCompleteTag","getItemText","documentClick","singleQuery","highlightMatchedText","dropdownStyle","tagsValue","curTags","addSuggestion","added","copy","highlight","match","s","noResultsMessage","_ref3","addTags","times","request_config","JSON","parse","post","url","location_types","terms","response","batch","multiple","parseInt","_tagsInput$addTag","handled","immediatePropagationStopped","stopImmediatePropagation","stopPropagation","isDefaultPrevented","type","tagName","ctrl","transcludeFn","clone","append","span","resize","THRESHOLD","css","originalValue","$parsers","unshift","$formatters","$observe","$modelValue","provider","globalDefaults","interpolationStatus","setDefaults","defaults","setActiveInterpolation","$get","$interpolate","converters","uid","localDefault","converter","getDefault","updateValue","globalValue","$parent","run","$templateCache","put"],"mappings":"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","file":"all.min.js","sourcesContent":["'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*!;\n  tagsInput = null;\n * ngTagsInput v2.0.1\n * http://mbenford.github.io/ngTagsInput\n *\n * Copyright (c) 2013-2014 Michael Benford\n * License: MIT\n *\n * Generated at 2014-04-13 21:25:38 -0300\n */\n(function () {\n  'use strict';\n\n  var KEYS = {\n    backspace: 8,\n    tab: 9,\n    enter: 13,\n    escape: 27,\n    space: 32,\n    up: 38,\n    down: 40,\n    comma: 188\n  };\n\n  function empty(obj) {\n    _.forOwn(obj, function (_value, key, coll) {\n      _.set(coll, key, null);\n    });\n  }\n\n  function SimplePubSub() {\n    var events = {};\n    return {\n      on: function on(names, handler) {\n        names.split(' ').forEach(function (name) {\n          if (!events[name]) {\n            events[name] = [];\n          }\n          events[name].push(handler);\n        });\n        return this;\n      },\n      trigger: function trigger(name, args) {\n        angular.forEach(events[name], function (handler) {\n          handler.call(null, args);\n        });\n        return this;\n      },\n      destroy: function destroy() {\n        empty(events);\n        events = null;\n      }\n    };\n  }\n\n  function makeObjectArray(array, key, key2) {\n    array = array || [];\n    if (array.length > 0 && !angular.isObject(array[0])) {\n      array.forEach(function (item, index) {\n        array[index] = _defineProperty({}, key, item);\n        if (key2) array[index][key2] = item;\n      });\n    }\n    return array;\n  }\n\n  function getArrayModelVal(array, options) {\n    if (options.arrayValueType === 'object') {\n      return (array || []).map(function (item) {\n        return _.isObject(item && item[options.valueProperty]) ? item[options.valueProperty] : item;\n      });\n    } else {\n      return _.pluck(array, options.valueProperty);\n    }\n  }\n\n  function findInObjectArray(array, obj, key) {\n    var item = null;\n    var i = 0;\n    var l = array.length;\n\n    if (_.isFunction(key)) {\n      var objVal = key(obj);\n      if (!objVal) return null;\n      for (; i < l; i++) {\n        if (objVal === key(array[i])) {\n          item = array[i];\n          break;\n        }\n      }\n    } else {\n      for (; i < l; i++) {\n        // I'm aware of the internationalization issues regarding toLowerCase()\n        // but I couldn't come up with a better solution right now\n        if (_.has(obj, key) && _.has(array[i], key) && (angular.toJson(array[i][key]) + '').toLowerCase() === (angular.toJson(obj[key]) + '').toLowerCase()) {\n          item = array[i];\n          break;\n        }\n      }\n    }\n    return item;\n  }\n\n  function replaceAll(str, substr, newSubstr) {\n    var expression = substr.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n    return str.replace(new RegExp(expression, 'gi'), newSubstr);\n  }\n\n  function matchTagsWithModel(tags, model, options) {\n    if (!model || !tags || !tags.length) return false;\n\n    if (!_.isArray(model)) {\n      return angular.equals(model, tags[0][options.valueProperty]) || angular.equals(model, tags[0]);\n    }\n\n    var array = getArrayModelVal(tags, options);\n    return _.some(array, function (tag, i) {\n      return angular.equals(model[i], tag) || angular.equals(model[i], tag[options.valueProperty]);\n    });\n  }\n\n  function findTagsForValue(tags, value, options) {\n    if (_.isArray(value)) {\n      var matches = _.filter(tags, function (tag) {\n        return _.find(value, function (val) {\n          return matchTag(tag, val, options.valueProperty, options.arrayValueType);\n        });\n      });\n\n      if (!options.addFromAutocompleteOnly && matches.length < value.length) {\n        _.each(value, function (v) {\n          if (!_.find(matches, function (m) {\n            return matchTag(m, v, options.valueProperty, options.arrayValueType);\n          })) matches.push(v);\n        });\n      }\n\n      return matches;\n    }\n\n    return _.filter(tags, function (tag) {\n      return matchTag(tag, value, options.valueProperty, options.modelType);\n    });\n  }\n\n  function matchTag(tag, value, valueProperty, modelType) {\n    var tagValue = valueProperty ? tag[valueProperty] : tag;\n    return modelType === 'object' ? objectContains(value, tagValue) : value == tagValue;\n  }\n\n  function objectContains(small, large) {\n    if (angular.isArray(small)) {\n      return angular.equals(small, large);\n    }\n    return _.every(small, function (val, key) {\n      return key === '$$hashKey' || (angular.isObject(val) ? objectContains(val, large[key]) : val == large[key]);\n    });\n  }\n\n  function selectAll(input) {\n    if (input.value) {\n      input.setSelectionRange(0, input.value.length);\n    }\n  }\n\n  function sortResults(results, tag, displayProperty) {\n    var valueFor = function valueFor(val) {\n      return displayProperty && val[displayProperty] ? val[displayProperty] : val;\n    };\n    var first = _.remove(results, function (result) {\n      return _.startsWith(valueFor(result), valueFor(tag));\n    });\n    first = _.sortBy(first, [function (result) {\n      return valueFor(result).length;\n    }]);\n    var reTag = new RegExp(valueFor(tag), \"i\");\n    var second = _.remove(results, function (result) {\n      return reTag.test(valueFor(result));\n    });\n    second = _.sortBy(second, [function (result) {\n      return valueFor(result).search(reTag);\n    }, function (result) {\n      return valueFor(result).length;\n    }]);\n    var third = _.sortBy(results, [function (result) {\n      return valueFor(result).length;\n    }]);\n    return first.concat(second, third);\n  }\n\n  function copyToClipboard(text) {\n    if (!_.isString(text)) return;\n    var copyElement = document.createElement(\"textarea\");\n    copyElement.style.position = 'fixed';\n    copyElement.style.opacity = '0';\n    copyElement.textContent = text;\n    var body = document.getElementsByTagName('body')[0];\n    body.appendChild(copyElement);\n    copyElement.select();\n    document.execCommand('copy');\n    body.removeChild(copyElement);\n  }\n\n  function stripHtml(html) {\n    var tmp = document.createElement(\"DIV\");\n    tmp.innerHTML = html;\n    return tmp.textContent || tmp.innerText || \"\";\n  }\n\n  var tagsInput = angular.module('cnTagsInput', []);\n\n  /**\n   * @ngdoc directive\n   * @name tagsInput\n   * @module cnTagsInput\n   *\n   * @description\n   * Renders an input box with tag editing support.\n   *\n   * @param {string} ngModel Assignable angular expression to data-bind to.\n   * @param {string=} [displayProperty=text] Property to be rendered as the tag label.\n   * @param {string=} [valueProperty=value] Property to be used as the value when modelType is not array/object.\n   * @param {number=} tabindex Tab order of the control.\n   * @param {string=} [placeholder=Add a tag] Placeholder text for the control.\n   * @param {number=} [minLength=3] Minimum length for a new tag.\n   * @param {number=} maxLength Maximum length allowed for a new tag.\n   * @param {boolean=} required Sets required validation error key.\n   * @param {number=} minTags Sets minTags validation error key if the number of tags added is less than minTags.\n   * @param {number=} maxTags Sets maxTags validation error key if the number of tags added is greater than maxTags.\n   * @param {boolean=} [allowLeftoverText=false] Sets leftoverText validation error key if there is any leftover text in\n   *                                             the input element when the directive loses focus.\n   * @param {string=} [removeTagSymbol=×] Symbol character for the remove tag button.\n   * @param {boolean=} [addOnEnter=true] Flag indicating that a new tag will be added on pressing the ENTER key.\n   * @param {boolean=} [addOnSpace=false] Flag indicating that a new tag will be added on pressing the SPACE key.\n   * @param {boolean=} [addOnComma=true] Flag indicating that a new tag will be added on pressing the COMMA key.\n   * @param {boolean=} [addOnBlur=false] Flag indicating that a new tag will be added when the input field loses focus.\n   * @param {boolean=} [clearOnBlur=false] Flag indicating whether to clear the typed text when the input field loses focus.\n   * @param {boolean=} [replaceSpacesWithDashes=false] Flag indicating that spaces will be replaced with dashes.\n   * @param {string=} [allowedTagsPattern=.+] Regular expression that determines whether a new tag is valid.\n   * @param {boolean=} [enableEditingLastTag=false] Flag indicating that the last tag will be moved back into\n   *                                                the new tag input box instead of being removed when the backspace key\n   *                                                is pressed and the input box is empty.\n   * @param {boolean=} [addFromAutocompleteOnly=false] Flag indicating that only tags coming from the autocomplete list will be allowed.\n   *                                                   When this flag is true, addOnEnter, addOnComma, addOnSpace, addOnBlur and\n   *                                                   allowLeftoverText values are ignored.\n   * @param {expression} onBeforeTagAdded Expression to evaluate upon adding a new tag. The new tag is available as $tag.\n   * @param {expression} onBeforeTagRemoved Expression to evaluate upon removing an existing tag. The removed tag is available as $tag.\n   * @param {expression} onBeforeTagChanged Expression to evaluate upon adding or removing a tag. The affected tag is available as $tag. Prev value avialble as $prev.\n   * @param {expression} onTagAdded Expression to evaluate upon adding a new tag. The new tag is available as $tag.\n   * @param {expression} onTagRemoved Expression to evaluate upon removing an existing tag. The removed tag is available as $tag.\n   * @param {expression} onTagChanged Expression to evaluate upon adding or removing a tag. The affected tag is available as $tag. Prev value avialble as $prev.\n   * @param {expression} onInit Expression to evaluate upon initializing model value.\n   * @param {string} modelType Defines ngModel type, if anything other than array, model is set to first tag in list\n   * @param {string} arrayValueType Defines ngModel[] type, if anything other than object, value is set mapped from object's values\n   * @param {boolean=} [hideTags=false] Flag indicating whether to hide tag list (for manually displaying tag list in other way)\n   * @param {boolean=} [dropdownIcon=false] Flag to show icon on right side\n   * @param {string=} [tagsStyle='tags'] Default tags style\n   * @param {boolean=} sortFilteredResults Flag to set whether to sort autocomplete list\n   */\n  tagsInput.directive('tagsInput', [\"$timeout\", \"$document\", \"tagsInputConfig\", \"$sce\", \"$rootScope\", function ($timeout, $document, tagsInputConfig, $sce, $rootScope) {\n    function TagList(options, events) {\n      var self = {},\n          getTagText,\n          setTagText,\n          tagIsValid;\n\n      getTagText = options.getTagText = function (tag) {\n        if (!_.isObject(tag)) return tag;\n        return options.itemFormatter ? options.itemFormatter(tag) : tag[options.displayProperty];\n      };\n\n      setTagText = function setTagText(tag, text) {\n        // only create tag object when not adding from auto-complete\n        if (tag[options.displayProperty]) return;\n\n        tag[options.displayProperty] = text;\n        if (options.valueProperty && !_.has(tag, options.valueProperty)) {\n          tag[options.valueProperty] = text;\n        }\n      };\n\n      tagIsValid = function tagIsValid(tag) {\n        var tagText = getTagText(tag) + '';\n\n        return (!options.minLength || tagText.length >= options.minLength) && (!options.maxLength || tagText.length <= options.maxLength) && options.allowedTagsPattern.test(tagText) && !findInObjectArray(self.items, tag, options.valueProperty || getTagText);\n      };\n\n      self.items = [];\n\n      self.addText = function (text) {\n        var tag = {};\n        setTagText(tag, text);\n        self.add(tag);\n      };\n\n      self.add = function (tag) {\n        if (tag.disabled) return;\n\n        var tagText = getTagText(tag);\n\n        if (tagText.trim) tagText = tagText.trim();\n\n        if (options.replaceSpacesWithDashes) {\n          tagText = tagText.replace(/\\s/g, '-');\n        }\n\n        setTagText(tag, tagText);\n\n        if (tagIsValid(tag)) {\n          if (options.maxTags && self.items.length >= options.maxTags) {\n            self.items.pop();\n            events.trigger('tag-removed', { $tag: tag, $event: 'tag-removed' });\n          }\n          self.items.push(tag);\n          events.trigger('tag-added', { $tag: tag, $event: 'tag-added' });\n        } else {\n          events.trigger('invalid-tag', { $tag: tag, $event: 'invalid-tag' });\n        }\n        return tag;\n      };\n\n      self.remove = function (index) {\n        var tag = self.items.splice(index, 1)[0];\n        events.trigger('tag-removed', { $tag: tag, $event: 'tag-removed' });\n        return tag;\n      };\n\n      self.removeLast = function () {\n        var tag,\n            lastTagIndex = self.items.length - 1;\n\n        if (options.enableEditingLastTag || self.selected) {\n          self.selected = null;\n          tag = self.remove(lastTagIndex);\n        } else if (!self.selected) {\n          self.selected = self.items[lastTagIndex];\n        }\n\n        return tag;\n      };\n\n      self.removeAll = function (e) {\n        e.preventDefault();\n        var tags = self.items.splice(0, self.items.length);\n        tags.forEach(function (tag) {\n          events.trigger('tag-removed', { $tag: tag, $event: 'tag-removed' });\n        });\n      };\n\n      self.copyAllToClipboard = function () {\n        return copyToClipboard(self.items.map(getTagText).map(stripHtml).join('\\n'));\n      };\n\n      self.destroy = function () {\n        empty(self);\n        self = null;\n      };\n\n      return self;\n    }\n\n    return {\n      restrict: 'E',\n      require: 'ngModel',\n      scope: {\n        tags: '=ngModel',\n        itemFormatter: '=',\n        ngDisabled: '=',\n        onBeforeTagAdded: '&',\n        onBeforeTagRemoved: '&',\n        onBeforeTagChanged: '&',\n        onTagAdded: '&',\n        onTagRemoved: '&',\n        onTagChanged: '&',\n        onInit: '&',\n        newTag: '=?'\n      },\n      replace: false,\n      transclude: true,\n      templateUrl: 'cnTagsInput/tags-input.html',\n      controller: [\"$scope\", \"$attrs\", \"$element\", function ($scope, $attrs, $element) {\n        tagsInputConfig.load('tagsInput', $scope, $attrs, {\n          placeholder: [String, ''],\n          tabindex: [Number],\n          removeTagSymbol: [String, String.fromCharCode(215)],\n          replaceSpacesWithDashes: [Boolean, false],\n          minLength: [Number, 2],\n          maxLength: [Number],\n          addOnEnter: [Boolean, true],\n          addOnSpace: [Boolean, false],\n          addOnComma: [Boolean, true],\n          addOnBlur: [Boolean, false],\n          clearOnBlur: [Boolean, false],\n          allowedTagsPattern: [RegExp, /.+/],\n          enableEditingLastTag: [Boolean, false],\n          required: [Boolean, false],\n          minTags: [Number],\n          maxTags: [Number],\n          displayProperty: [String, 'text'],\n          valueProperty: [String],\n          allowLeftoverText: [Boolean, false],\n          addFromAutocompleteOnly: [Boolean, false],\n          tagClass: [String, ''],\n          modelType: [String, 'array'],\n          arrayValueType: [String, 'object'],\n          hideTags: [Boolean, false],\n          dropdownIcon: [Boolean, false],\n          tagsStyle: [String, 'tags'],\n          allowBulk: [Boolean, false],\n          bulkSingleRequest: [String, ''],\n          bulkDelimiter: [RegExp, /, ?|\\n/],\n          bulkPlaceholder: [String, 'Enter a list separated by commas or new lines'],\n          sortFilteredResults: [Boolean, false],\n          showClearAll: [Boolean, false],\n          showClearCache: [Boolean, false],\n          showButton: [Boolean, false]\n        });\n\n        var options = $scope.options;\n        var input = options.input = $element.find('input.input');\n\n        function handleKeydown(e) {\n          $scope.events.trigger('input-keydown', e);\n        }\n\n        input.on('keydown', handleKeydown);\n\n        $scope.$on('$destroy', function () {\n          input.off('keydown', handleKeydown);\n          input = null;\n          empty(options);\n          options = null;\n          $scope.events.destroy();\n          $scope.tagList.destroy();\n          $scope.processBulk = null;\n        });\n\n        if (!options.valueProperty && (!/object|array/.test(options.modelType) || options.arrayValueType !== 'object')) {\n          options.valueProperty = 'value';\n        }\n\n        if ($scope.itemFormatter) options.itemFormatter = $scope.itemFormatter;\n\n        if (options.tagsStyle === 'tags') {\n          options.tagClass = options.tagClass || 'label-primary';\n        }\n\n        if (options.allowBulk && (options.modelType !== 'array' || options.maxTags === 1)) {\n          options.allowBulk = false;\n        }\n\n        $scope.events = new SimplePubSub();\n        $scope.tagList = new TagList(options, $scope.events);\n\n        this.registerAutocomplete = function () {\n          return {\n            addTag: function addTag(tag) {\n              return $scope.tagList.add(tag);\n            },\n            focusInput: function focusInput() {\n              input[0].focus();\n            },\n            blurInput: function blurInput() {\n              input[0].blur();\n            },\n            getTags: function getTags() {\n              return $scope.tagList.items;\n            },\n            getModel: function getModel() {\n              return $scope.tags;\n            },\n            getOptions: function getOptions() {\n              return options;\n            },\n            on: function on(name, handler) {\n              $scope.events.on(name, handler);\n              return this;\n            },\n            registerProcessBulk: function registerProcessBulk(fn) {\n              $scope.processBulk = function () {\n                fn($scope.bulkTags).then(function () {\n                  $scope.showBulk = false;\n                  $scope.bulkTags = '';\n                });\n              };\n            },\n            registerSuggestionList: function registerSuggestionList(suggestionList) {\n              $scope.tagList.suggestionList = suggestionList;\n            }\n          };\n        };\n      }],\n      link: function link(scope, element, attrs, ngModelCtrl) {\n        function tagsInputTag() {}\n        scope.__tag = new tagsInputTag();\n\n        var hotkeys = [KEYS.enter, KEYS.comma, KEYS.space, KEYS.backspace],\n            tagList = scope.tagList,\n            events = scope.events,\n            options = scope.options,\n            input = element.find('input.input'),\n            textarea = element.find('textarea'),\n            div = element.find('div'),\n            blurTimeout;\n\n        if (attrs.inputId && !ngModelCtrl.$name) {\n          ngModelCtrl.$name = attrs.inputId;\n        }\n\n        // before callbacks allow code to modify tag before it's added\n        // after callback fired after ngModel has chance to update\n        function beforeAndAfter(before, after) {\n          return function () {\n            var args = arguments;\n            before.apply(this, args);\n            $timeout(function () {\n              after.apply(this, args);\n            });\n          };\n        }\n\n        function inlineChangeTags() {\n          return function () {\n            if (arguments.length > 0 && _.isArray(arguments[0].$tag)) {\n              var newTags = arguments[0].$tag;\n              var isObjectArray = _.every(newTags, function (v) {\n                return (typeof v === 'undefined' ? 'undefined' : _typeof(v)) === 'object' && v !== null && options.displayProperty && v[options.displayProperty];\n              });\n              if (isObjectArray) {\n                if (scope.tagList && scope.tagList.items && newTags) {\n                  scope.tagList.items = newTags;\n                }\n              }\n            }\n          };\n        }\n\n        events.on('tag-added', beforeAndAfter(scope.onBeforeTagAdded, scope.onTagAdded)).on('tag-removed', beforeAndAfter(scope.onBeforeTagRemoved, scope.onTagRemoved)).on('tag-changed', beforeAndAfter(scope.onBeforeTagChanged, scope.onTagChanged)).on('tag-changed', inlineChangeTags()).on('tag-init', scope.onInit).on('tag-added tag-removed', function (e) {\n          if (!options.maxTags || options.maxTags > scope.tagList.items.length) {\n            selectAll(options.input[0]);\n          } else {\n            scope.newTag.text = '';\n          }\n          if (options.modelType === 'array') {\n            if (!options.valueProperty) {\n              scope.tags = scope.tagList.items;\n            } else {\n              scope.tags = getArrayModelVal(scope.tagList.items, options);\n            }\n            if (scope.tagList.items.length >= options.minTags) {\n              ngModelCtrl.$setValidity('tv4-400', true);\n            }\n          } else {\n            if (e.$event === 'tag-removed') {\n              scope.tags = undefined;\n            } else {\n              if (!options.valueProperty) {\n                scope.tags = e.$tag;\n              } else {\n                scope.tags = _.has(e.$tag, options.valueProperty) ? e.$tag[options.valueProperty] : e.$tag[options.displayProperty];\n              }\n            }\n          }\n        }).on('invalid-tag', function () {\n          scope.newTag.invalid = true;\n        }).on('input-change', function () {\n          tagList.selected = null;\n          scope.newTag.invalid = null;\n        }).on('input-focus', function () {\n          ngModelCtrl.$setValidity('leftoverText', true);\n        }).on('input-blur', function () {\n          if (!options.addFromAutocompleteOnly) {\n            if (options.addOnBlur && scope.newTag.text) {\n              tagList.addText(scope.newTag.text);\n            }\n          }\n\n          // Reset newTag\n          if (options.clearOnBlur) {\n            scope.newTag.text = '';\n            scope.newTag.invalid = null;\n          }\n        });\n\n        scope.newTag = { text: '', invalid: null };\n\n        scope.getDisplayText = scope.itemFormatter || function (tag) {\n          return tag && ((tag[options.displayProperty] || 'undefined') + '').trim();\n        };\n\n        scope.getDisplayHtml = function (tag) {\n          return $sce.trustAsHtml(scope.getDisplayText(tag));\n        };\n\n        scope.handleShowTooltip = function (e) {\n          var $target = $(e.target).closest('.tag-item.overflows-to-tooltip');\n          if ($target.outerWidth() === $target.offsetParent().width()) {\n            $target.find('.tag-overflow-tooltip').fadeIn(200);\n          }\n        };\n\n        scope.handleHideTooltip = function (e) {\n          $(e.target).closest('.tag-item.overflows-to-tooltip').find('.tag-overflow-tooltip').fadeOut(200);\n        };\n\n        scope.track = function (tag) {\n          return tag[options.displayProperty];\n        };\n\n        scope.newTagChange = function () {\n          events.trigger('input-change', scope.newTag.text);\n        };\n\n        scope.processBulk = scope.processBulk || function () {\n          var tags = scope.bulkTags.split(options.bulkDelimiter);\n          _.each(tags, function (text) {\n            var tag = {};\n            tag[options.displayProperty] = text;\n            scope.tagList.add(tag);\n          });\n          scope.showBulk = false;\n          scope.bulkTags = '';\n        };\n\n        var first = true;\n\n        scope.triggerInit = function (value, prev) {\n          var criteria = options.valueProperty ? _defineProperty({}, options.valueProperty, value) : value;\n          if (!tagList.items.length || !_.find(tagList.items, criteria)) {\n            events.trigger('tag-init', {\n              $tag: value,\n              $prev: prev,\n              $event: 'tag-init',\n              $setter: function $setter(val) {\n                if (val && !_.isObject(val)) {\n                  var _ref2;\n\n                  tagList.items = [(_ref2 = {}, _defineProperty(_ref2, options.displayProperty, val), _defineProperty(_ref2, options.valueProperty, val), _ref2)];\n                } else {\n                  tagList.items = _.isArray(val) ? val : [val];\n                }\n                return tagList.items;\n              }\n            });\n          }\n        };\n\n        scope.$watch('tags', function (value, prev) {\n          var changed = !angular.equals(value, prev);\n          var init = !changed && first;\n\n          if (init) {\n            scope.triggerInit(value, prev);\n          }\n          if (changed) {\n            events.trigger('tag-changed', {\n              $tag: value,\n              $prev: prev,\n              $event: 'tag-changed'\n            });\n          }\n\n          if (options.modelType === 'array') {\n            if (_.isArray(value)) {\n              if (value.length) {\n                if (!matchTagsWithModel(tagList.items, scope.tags, options)) {\n                  scope.triggerInit(value, prev);\n                }\n                if (!matchTagsWithModel(tagList.items, scope.tags, options) || tagList.items.length !== scope.tags.length) {\n                  tagList.items = makeObjectArray(value, options.displayProperty, options.valueProperty);\n                  scope.tags = getArrayModelVal(tagList.items, options);\n                  return;\n                }\n              } else {\n                tagList.items = [];\n                if (angular.isUndefined(prev)) return;\n              }\n            } else if (value === undefined) {\n              tagList.items = [];\n              scope.tags = [];\n              return;\n            }\n          } else if (angular.isDefined(value)) {\n            if (_.isArray(value)) {\n              if (value.length) {\n                //if(options.modelType === 'object') {\n                if (!options.valueProperty) {\n                  scope.tags = value[0];\n                } else {\n                  scope.tags = value[0][options.valueProperty];\n                }\n\n                return;\n              } else {\n                scope.tags = undefined;\n              }\n            } else {\n              if (options.modelType === 'object') {\n                if (value !== null) tagList.items = [value];\n              } else {\n                if (_.isObject(value)) {\n                  tagList.items = [value];\n\n                  var val = value[options.valueProperty];\n                  if (_.isUndefined(val)) val = value[options.displayProperty];\n                  scope.tags = val;\n\n                  return;\n                } else if (!_.isUndefined(value) && (!tagList.items.length || tagList.items[0][options.valueProperty] !== value)) {\n                  scope.triggerInit(value, prev);\n                }\n              }\n            }\n          } else if (!value && tagList.items.length) {\n            tagList.items = [];\n          }\n\n          if (!init && changed) {\n            ngModelCtrl.$setDirty();\n          }\n\n          // hack because schemaForm is incorrectly invalidating model sometimes\n          ngModelCtrl.$setValidity('schemaForm', true);\n          if (options.modelType === 'array') {\n            ngModelCtrl.$setValidity('tv4-401', value && options.maxTags ? value.length <= options.maxTags : true);\n            ngModelCtrl.$setValidity('tv4-302', value ? angular.isDefined(options.minTags) ? value.length >= options.minTags : true : false);\n          } else {\n            if (!init) {\n              ngModelCtrl.$setValidity('tv4-302', !options.required || !angular.isUndefined(value));\n            }\n          }\n\n          first = false;\n        }, true);\n\n        function handleInputKeydown(e) {\n          // This hack is needed because jqLite doesn't implement stopImmediatePropagation properly.\n          // I've sent a PR to Angular addressing this issue and hopefully it'll be fixed soon.\n          // https://github.com/angular/angular.js/pull/4833\n          if (e.isImmediatePropagationStopped && e.isImmediatePropagationStopped()) {\n            return;\n          }\n\n          var key = e.keyCode,\n              isModifier = e.shiftKey || e.altKey || e.ctrlKey || e.metaKey,\n              addKeys = {},\n              shouldAdd,\n              shouldRemove;\n\n          if (isModifier || hotkeys.indexOf(key) === -1) {\n            return;\n          }\n\n          addKeys[KEYS.enter] = options.addOnEnter;\n          addKeys[KEYS.comma] = options.addOnComma;\n          addKeys[KEYS.space] = options.addOnSpace;\n\n          shouldAdd = !options.addFromAutocompleteOnly && addKeys[key];\n          shouldRemove = !shouldAdd && key === KEYS.backspace && scope.newTag.text.length === 0;\n\n          if (shouldAdd) {\n            tagList.addText(scope.newTag.text);\n\n            scope.$apply();\n            e.preventDefault();\n          } else if (shouldRemove) {\n            var tag = tagList.removeLast();\n            if (tag && options.enableEditingLastTag) {\n              scope.newTag.text = tag[options.displayProperty];\n            }\n\n            scope.$apply();\n            e.preventDefault();\n          }\n        }\n\n        function handleInputBlur(e) {\n          blurTimeout = $timeout(function () {\n            // race condition can cause input to be destroyed before timeout ends\n            if (!input) return false;\n            var activeElement = $document.prop('activeElement'),\n                lostFocusToBrowserWindow = activeElement === input[0],\n                lostFocusToChildElement = element.find('.host')[0].contains(activeElement);\n\n            if (lostFocusToBrowserWindow || !lostFocusToChildElement) {\n              scope.hasFocus = false;\n              events.trigger('input-blur', e);\n            }\n          }, 150); // timeout so that click event triggers first\n        }\n\n        function handleInputFocus(e) {\n          if (e) e.preventDefault();\n          if (scope.ngDisabled) return;\n\n          selectAll(e.target);\n\n          if (blurTimeout) $timeout.cancel(blurTimeout);\n\n          scope.hasFocus = true;\n          events.trigger('input-focus', input.val());\n\n          if (!/apply|digest/.test(scope.$root.$$phase)) scope.$apply();\n        }\n\n        function handleTextareaKeydown(e) {\n          if (e.keyCode === KEYS.enter) {\n            if (!e.altKey && !e.ctrlKey && !e.metaKey && !e.shiftKey) {\n              e.preventDefault();\n              scope.processBulk();\n            }\n          }\n        }\n\n        function handleDivClick(e) {\n          var $target = $(e.target);\n          if (!$target.closest('.suggestion').length && !$target.closest('.overflows-to-tooltip').length &&\n          // we don't want any of the buttons underneath to trigger\n          !$target.parent().hasClass('help-block')) {\n            e.preventDefault();\n            input[0].focus();\n          }\n        }\n\n        // stupid ugly hack to fix order between input and autocomplete events\n        var uglyHackTimeout = $timeout(function () {\n          input.on('keydown', handleInputKeydown).on('focus', handleInputFocus).on('blur', handleInputBlur);\n        });\n\n        textarea.on('keydown', handleTextareaKeydown);\n\n        div.on('click', handleDivClick);\n\n        scope.$on('$destroy', function () {\n          input.off('keydown', handleInputKeydown).off('focus', handleInputFocus).off('blur', handleInputBlur);\n\n          textarea.off('keydown', handleTextareaKeydown);\n          div.off('click', handleDivClick);\n          input = null;\n          textarea = null;\n          div = null;\n          events.destroy();\n          events = null;\n          first = null;\n          hotkeys = null;\n          options = null;\n          tagList = null;\n          $timeout.cancel(uglyHackTimeout);\n        });\n      }\n    };\n  }]);\n\n  /**\n   * @ngdoc directive\n   * @name autoComplete\n   * @module cnTagsInput\n   *\n   * @description\n   * Provides autocomplete support for the tagsInput directive.\n   *\n   * @param {expression} source Expression to evaluate upon changing the input content. The input value is available as\n   *                            $query. The result of the expression must be a promise that eventually resolves to an\n   *                            array of strings.\n   * @param {number=} [debounceDelay=100] Amount of time, in milliseconds, to wait before evaluating the expression in\n   *                                      the source option after the last keystroke.\n   * @param {number=} [minLength=3] Minimum number of characters that must be entered before evaluating the expression\n   *                                 in the source option.\n   * @param {boolean=} [highlightMatchedText=true] Flag indicating that the matched text will be highlighted in the\n   *                                               suggestions list.\n   * @param {number=} [maxResultsToShow=10] Maximum number of results to be displayed at a time.\n   */\n  tagsInput.directive('autoComplete', [\"$document\", \"$timeout\", \"$filter\", \"$sce\", \"tagsInputConfig\", \"$parse\", 'Api', '$q', function ($document, $timeout, $filter, $sce, tagsInputConfig, $parse, Api, $q) {\n    function SuggestionList(scope, options) {\n      var self = {},\n          debouncedLoadId,\n          getDifference,\n          lastPromise,\n          groupList,\n          splitListItems,\n          formatItemText,\n          mapIndexes;\n\n      groupList = function groupList(list, groupBy) {\n        var filtered = {},\n            map = [],\n            index = 0,\n            keys;\n\n        // loop through each item in the list\n        _.each(list, function (item) {\n          keys = $parse(groupBy)(item);\n          if (!_.isArray(keys)) keys = [keys];\n          _.each(keys, function (key) {\n            if (!filtered[key]) {\n              filtered[key] = [];\n            }\n            filtered[key].push(item);\n          });\n        });\n\n        _.each(filtered, function (group) {\n          group.indexes = [];\n          _.each(group, function (item) {\n            group.indexes.push(index++);\n            map.push(item);\n          });\n        });\n\n        return {\n          groups: filtered,\n          map: map\n        };\n      };\n\n      formatItemText = function formatItemText(item, formatter) {\n        if (formatter) {\n          if (!_.isArray(formatter)) {\n            formatter = [formatter, {}];\n          }\n          return $parse(formatter[0])((formatter[1].val = item) && formatter[1]);\n        }\n\n        return item;\n      };\n\n      splitListItems = function splitListItems(items) {\n        var keys = [];\n\n        function addItem(key, item, group, prop) {\n          var text = _.isObject(item) ? item[prop || options.tagsInput.displayProperty] : item,\n              toAdd = {\n            text: formatItemText(text, group.formatter),\n            value: text,\n            key: key,\n            childKey: prop\n          };\n\n          if (!_.find(group.items, toAdd)) {\n            group.items.push(toAdd);\n          }\n        }\n\n        _.each(scope.searchKeys, function (group) {\n          var key = group.key;\n          group.items = [];\n\n          _.each(items, function (item) {\n            if (item[key]) {\n              if (_.isArray(item[key])) {\n                _.each(item[key], function (child) {\n                  addItem(key, child, group, group.childKey);\n                });\n              } else {\n                addItem(key, item[key], group, group.childKey);\n              }\n            }\n          });\n          keys.push(group);\n        });\n\n        return keys;\n      };\n\n      mapIndexes = function mapIndexes(items) {\n        var map = [],\n            index = 0;\n\n        _.each(items, function (group) {\n          group.indexes = [];\n          _.each(group.items, function (item) {\n            group.indexes.push(index++);\n            map.push(item);\n          });\n        });\n\n        return map;\n      };\n\n      getDifference = function getDifference(array1, array2) {\n        if (!array2.length) {\n          return array1.filter(function (item) {\n            return item[options.tagsInput.displayProperty] !== '';\n          });\n        }\n        return array1.filter(function (item) {\n          return !findInObjectArray(array2, item, options.tagsInput.valueProperty || options.tagsInput.getTagText);\n        });\n      };\n\n      self.reset = function () {\n        lastPromise = null;\n\n        self.items = [];\n        self.visible = false;\n        self.index = -1;\n        self.selected = null;\n        self.query = null;\n\n        $timeout.cancel(debouncedLoadId);\n      };\n\n      self.show = function () {\n        self.selected = null;\n        self.visible = true;\n        self.select(0);\n      };\n\n      self.load = function (query, tags) {\n        if (query.length < options.minLength) {\n          self.reset();\n          return;\n        }\n\n        var promise,\n\n        //filterBy = {},\n        filterBy = query,\n            groups,\n            processItems = function processItems(items) {\n          if (promise && promise !== lastPromise) {\n            return;\n          }\n\n          if (scope.searchKeys) {\n            scope.isGroups = true;\n            //filterBy = query;\n            items = splitListItems(items);\n          }\n          if (_.isObject(items) && !_.isArray(items)) {\n            scope.isGroups = true;\n            items = _.map(items, function (list, group) {\n              return {\n                items: list,\n                label: group\n              };\n            });\n          }\n          if (scope.isGroups) {\n            _.each(items, function (group) {\n              group.items = getDifference(group.items, tags);\n              if (query) {\n                var reconciliateItems = {};\n                group.items.map(function (item, idx) {\n                  item.__uniqueid = _.uniqueId('__uniqueid');\n                  reconciliateItems[item.__uniqueid] = _.cloneDeep(item);\n                  if ('key' in item) delete item.key;\n                  if ('childKey' in item) delete item.childKey;\n                });\n                group.items = $filter('cnFilter')(group.items, filterBy);\n                if (options.tagsInput.sortFilteredResults) {\n                  group.items = sortResults(group.items, filterBy, options.tagsInput.displayProperty);\n                }\n                group.items.map(function (item) {\n                  var ref = reconciliateItems[item.__uniqueid];\n                  if ('key' in ref) item.key = ref.key;\n                  if ('childKey' in ref) item.childKey = ref.childKey;\n                  delete item.__uniqueid;\n                });\n              }\n\n              group.items = group.items.slice(0, options.maxResultsToShow);\n            });\n            self.itemMap = mapIndexes(items);\n          } else {\n            //filterBy[options.tagsInput.displayProperty] = query;\n            items = makeObjectArray(items.data || items, options.tagsInput.displayProperty);\n            items = getDifference(items, tags);\n            if (query && !options.skipFiltering) {\n              items = $filter('cnFilter')(items, filterBy);\n            }\n\n            if (options.tagsInput.sortFilteredResults) {\n              items = sortResults(items, filterBy, options.tagsInput.displayProperty);\n            }\n\n            items = items.slice(0, options.maxResultsToShow);\n\n            if (options.groupBy) {\n              groups = groupList(items, options.groupBy);\n              items = groups.groups;\n              self.itemMap = groups.map;\n            }\n          }\n\n          self.items = items;\n          self.show();\n        };\n\n        $timeout.cancel(debouncedLoadId);\n        self.query = query;\n        debouncedLoadId = $timeout(function () {\n          self._load(query, promise).then(processItems);\n        }, options.minLength ? options.debounceDelay : 0, false);\n      };\n\n      self.clearCache = function (event, query) {\n        event.preventDefault();\n        if (scope._source) scope.source = scope._source;\n        var source = scope.source;\n        source({ $query: query, options: { refreshData: true } }).then(function (results) {\n          scope._source = source;\n          scope.source = function () {\n            return results;\n          };\n          scope.tagsInput.focusInput();\n        });\n      };\n\n      self._load = function (query, promise) {\n        var d = $q.defer();\n        var source = scope.source({ $query: query });\n        if (_.isArray(source)) {\n          $timeout(function () {\n            d.resolve(source || []);\n          });\n        } else {\n          promise = source;\n          lastPromise = promise;\n          return promise;\n        }\n        return d.promise;\n      };\n\n      self.selectNext = function () {\n        self.select(++self.index);\n      };\n\n      self.selectPrior = function () {\n        self.select(--self.index);\n      };\n\n      self.select = function (index) {\n        var list = self.itemMap || self.items;\n        if (index < 0) {\n          index = list.length - 1;\n        } else if (index >= list.length) {\n          index = 0;\n        }\n        self.index = index;\n        if (self.itemMap) {\n          self.selected = self.itemMap[index];\n        } else {\n          self.selected = self.items[index];\n        }\n      };\n\n      return self;\n    }\n\n    function encodeHTML(value) {\n      return value ? value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') : '';\n    }\n\n    return {\n      restrict: 'E',\n      require: '^tagsInput',\n      scope: {\n        source: '&',\n        searchKeys: '=?'\n      },\n      templateUrl: function templateUrl(elem, attrs) {\n        return attrs.customTemplateUrl || 'cnTagsInput/auto-complete.html';\n      },\n      link: function link(scope, element, attrs, tagsInputCtrl) {\n        var hotkeys = [KEYS.enter, KEYS.tab, KEYS.escape, KEYS.up, KEYS.down],\n            suggestionList,\n            tagsInput,\n            options,\n            getItemText,\n            documentClick;\n\n        function autoCompleteTag() {}\n        scope.__tag = new autoCompleteTag();\n\n        tagsInputConfig.load('autoComplete', scope, attrs, {\n          debounceDelay: [Number, 250],\n          minLength: [Number, 3],\n          singleQuery: [Boolean, false],\n          highlightMatchedText: [Boolean, true],\n          maxResultsToShow: [Number, 75],\n          groupBy: [String, ''],\n          skipFiltering: [Boolean, false]\n        });\n\n        options = scope.options;\n\n        tagsInput = tagsInputCtrl.registerAutocomplete();\n        scope.tagsInput = tagsInput;\n\n        options.tagsInput = tagsInput.getOptions();\n\n        if (options.minLength === 0 /* && _.isArray(scope.source())*/) {\n            options.tagsInput.dropdownIcon = true;\n            if (options.tagsInput.maxTags === 1) {\n              options.tagsInput.dropdownStyle = 'caret';\n            } else {\n              options.tagsInput.dropdownStyle = 'fa fa-plus';\n            }\n          } else {\n          options.tagsInput.dropdownStyle = 'fa fa-search';\n        }\n\n        suggestionList = new SuggestionList(scope, options);\n        tagsInput.registerSuggestionList(suggestionList);\n\n        getItemText = options.tagsInput.itemFormatter || function (item) {\n          return String(item[options.tagsInput.displayProperty]);\n        };\n\n        scope.suggestionList = suggestionList;\n\n        var tagsValue = tagsInput.getModel();\n\n        if (options.singleQuery && tagsValue && !angular.equals(tagsValue, [])) {\n          suggestionList._load().then(function (results) {\n            var tags = findTagsForValue(results, tagsValue, options.tagsInput);\n            var curTags = tagsInput.getTags();\n            if (!angular.equals(tags, curTags)) {\n              curTags.length = 0; // hack to get event to retrigger\n              tags.forEach(function (tag) {\n                return tagsInput.addTag(tag);\n              });\n            }\n          });\n        }\n\n        scope.addSuggestion = function (e) {\n          e.preventDefault();\n\n          var added = false;\n\n          if (suggestionList.selected) {\n            tagsInput.addTag(angular.copy(suggestionList.selected));\n\n            if (!options.tagsInput.maxTags || tagsInput.getTags().length < options.tagsInput.maxTags) {\n              var i = suggestionList.items.indexOf(suggestionList.selected);\n              suggestionList.items.splice(i, 1);\n              suggestionList.select(i);\n              tagsInput.focusInput();\n            } else {\n              suggestionList.reset();\n              tagsInput.blurInput();\n            }\n\n            added = true;\n          }\n          return added;\n        };\n\n        scope.highlight = function (item, key) {\n          var text = getItemText(item, key);\n          if (suggestionList.query && options.highlightMatchedText) {\n            text = _(text.match(/(<[^>]*>|[^<]*)/g)) // regex will create a list of all html and text nodes\n            .map(function (s) {\n              return s.length && s[0] !== '<' ? replaceAll(s, suggestionList.query, '<b>$&</b>') : s;\n            }).join('');\n          }\n          return $sce.trustAsHtml('<a>' + text + '</a>');\n        };\n\n        scope.track = function (item, key) {\n          return getItemText(item, key);\n        };\n\n        scope.noResultsMessage = function (_ref3) {\n          var visible = _ref3.visible,\n              query = _ref3.query;\n\n          if (!query) return 'No options...';\n          return $sce.trustAsHtml('No results for <b>' + query + '</b>...');\n        };\n\n        tagsInput.registerProcessBulk(function (bulkTags) {\n          var tags = bulkTags.split(options.tagsInput.bulkDelimiter);\n          var addTags = function addTags(i) {\n            return function (data) {\n              _.times(i, function (i) {\n                if (data[i]) tagsInput.addTag(data[i]);\n              });\n            };\n          };\n\n          if (options.tagsInput.bulkSingleRequest) {\n            var request_config = JSON.parse(options.tagsInput.bulkSingleRequest);\n            return Api.post({\n              url: request_config.url,\n              data: {\n                location_types: request_config.location_types,\n                terms: tags\n              }\n            }).then(function (response) {\n              response.map(function (item) {\n                tagsInput.addTag(item);\n              });\n            });\n          }\n          // in case a query is involved...doesn't hurt to use even if not\n          return Api.batch(function () {\n            for (var i = 0, l = tags.length; i < l; i++) {\n              if (options.tagsInput.maxTags && tagsInput.getTags().length >= options.tagsInput.maxTags) break;\n              var tag = tags[i];\n              var times = 1;\n              var multiple = tags[i].match(/(.*) ?\\[(\\d+)\\]$/);\n\n              if (multiple) {\n                tag = multiple[1];\n                times = parseInt(multiple[2]);\n              }\n\n              var results = scope.source({ $query: tag });\n\n              if (_.isArray(results)) {\n                if (results.length) {\n                  if (!options.skipFiltering) {\n                    var filterBy = tag;\n                    results = $filter('cnFilter')(results, filterBy);\n                  }\n                  if (options.tagsInput.sortFilteredResults) {\n                    results = sortResults(results, tag, options.tagsInput.displayProperty);\n                  }\n                  addTags(times)(results);\n                } else if (!options.tagsInput.addFromAutocompleteOnly) {\n                  var _tagsInput$addTag;\n\n                  tagsInput.addTag((_tagsInput$addTag = {}, _defineProperty(_tagsInput$addTag, options.tagsInput.displayProperty, tag), _defineProperty(_tagsInput$addTag, options.tagsInput.valueProperty, tag), _tagsInput$addTag));\n                }\n              } else if (results.then) {\n                results.then(addTags(times));\n              }\n            }\n          });\n        });\n\n        tagsInput.on('input-change', function (value) {\n          if (value || !options.minLength) {\n            suggestionList.load(value, tagsInput.getTags());\n          } else {\n            suggestionList.reset();\n          }\n        }).on('input-focus', function (value) {\n          if (!suggestionList.visible) {\n            suggestionList.load(value, tagsInput.getTags());\n          }\n        }).on('input-keydown', function (e) {\n          var key, handled;\n\n          if (hotkeys.indexOf(e.keyCode) === -1) {\n            return;\n          }\n\n          // This hack is needed because jqLite doesn't implement stopImmediatePropagation properly.\n          // I've sent a PR to Angular addressing this issue and hopefully it'll be fixed soon.\n          // https://github.com/angular/angular.js/pull/4833\n          var immediatePropagationStopped = false;\n          e.stopImmediatePropagation = function () {\n            immediatePropagationStopped = true;\n            e.stopPropagation();\n          };\n          e.isImmediatePropagationStopped = function () {\n            return immediatePropagationStopped;\n          };\n\n          if (suggestionList.visible) {\n            key = e.keyCode;\n            handled = false;\n\n            if (key === KEYS.down) {\n              suggestionList.selectNext();\n              handled = true;\n            } else if (key === KEYS.up) {\n              suggestionList.selectPrior();\n              handled = true;\n            } else if (key === KEYS.escape) {\n              suggestionList.reset();\n              handled = true;\n            } else if (key === KEYS.enter) {\n              handled = scope.addSuggestion(e);\n            }\n\n            if (handled) {\n              e.preventDefault();\n              e.stopImmediatePropagation();\n              scope.$apply();\n            }\n          }\n        }).on('input-blur', function (e) {\n          //changed to use document click or focus, as this fires too soon and cancels\n          //automcomplete click events\n          suggestionList.reset();\n        });\n\n        documentClick = function documentClick(e) {\n          if (e.isDefaultPrevented()) return;\n\n          if (suggestionList.visible) {\n            // if autocomplete option was selected, or click/focus triggered outside of directive\n            if (($(e.target).closest('.suggestion').length || !$(e.target).closest(element[0]).length) && !(e.type === 'blur' && !/^(input|select|textarea|button|a)$/i.test(e.target.tagName))) {\n              suggestionList.reset();\n              if (!/apply|digest/.test(scope.$root.$$phase)) scope.$apply();\n            }\n          }\n        };\n\n        $document.on('click', documentClick).on('blur', documentClick);\n\n        scope.$on('$destroy', function () {\n          $document.off('click', documentClick).off('blur', documentClick);\n\n          empty(tagsInput);\n          tagsInput = null;\n\n          empty(options);\n          options = null;\n        });\n      }\n    };\n  }]);\n\n  /**\n   * @ngdoc directive\n   * @name tiTranscludeAppend\n   * @module cnTagsInput\n   *\n   * @description\n   * Re-creates the old behavior of ng-transclude. Used internally by tagsInput directive.\n   */\n  tagsInput.directive('tiTranscludeAppend', function () {\n    return function (scope, element, attrs, ctrl, transcludeFn) {\n      transcludeFn(function (clone) {\n        element.append(clone);\n      });\n    };\n  });\n\n  /**\n   * @ngdoc directive\n   * @name tiAutosize\n   * @module cnTagsInput\n   *\n   * @description\n   * Automatically sets the input's width so its content is always visible. Used internally by tagsInput directive.\n   */\n  tagsInput.directive('tiAutosize', function () {\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      link: function link(scope, element, attrs, ctrl) {\n        var THRESHOLD = 3,\n            span,\n            resize;\n\n        span = angular.element('<span class=\"input\"></span>');\n        span.css('display', 'none').css('visibility', 'hidden').css('width', 'auto').css('white-space', 'pre');\n\n        element.parent().append(span);\n\n        resize = function resize(originalValue) {\n          var value = originalValue,\n              width;\n\n          if (angular.isString(value) && value.length === 0) {\n            value = attrs.placeholder;\n          }\n\n          if (value) {\n            span.text(value);\n            span.css('display', '');\n            width = span.prop('offsetWidth');\n            span.css('display', 'none');\n          }\n\n          element.css('width', width ? width + THRESHOLD + 'px' : '');\n\n          return originalValue;\n        };\n\n        ctrl.$parsers.unshift(resize);\n        ctrl.$formatters.unshift(resize);\n\n        attrs.$observe('placeholder', function (value) {\n          if (!ctrl.$modelValue) {\n            resize(value);\n          }\n        });\n      }\n    };\n  });\n\n  /**\n   * @ngdoc service\n   * @name tagsInputConfig\n   * @module cnTagsInput\n   *\n   * @description\n   * Sets global configuration settings for both tagsInput and autoComplete directives. It's also used internally to parse and\n   * initialize options from HTML attributes.\n   */\n  tagsInput.provider('tagsInputConfig', function () {\n    var globalDefaults = {},\n        interpolationStatus = {};\n\n    /**\n     * @ngdoc method\n     * @name setDefaults\n     * @description Sets the default configuration option for a directive.\n     * @methodOf tagsInputConfig\n     *\n     * @param {string} directive Name of the directive to be configured. Must be either 'tagsInput' or 'autoComplete'.\n     * @param {object} defaults Object containing options and their values.\n     *\n     * @returns {object} The service itself for chaining purposes.\n     */\n    this.setDefaults = function (directive, defaults) {\n      globalDefaults[directive] = defaults;\n      return this;\n    };\n\n    /***\n     * @ngdoc method\n     * @name setActiveInterpolation\n     * @description Sets active interpolation for a set of options.\n     * @methodOf tagsInputConfig\n     *\n     * @param {string} directive Name of the directive to be configured. Must be either 'tagsInput' or 'autoComplete'.\n     * @param {object} options Object containing which options should have interpolation turned on at all times.\n     *\n     * @returns {object} The service itself for chaining purposes.\n     */\n    this.setActiveInterpolation = function (directive, options) {\n      interpolationStatus[directive] = options;\n      return this;\n    };\n\n    this.$get = [\"$interpolate\", function ($interpolate) {\n      var converters = {};\n      converters[String] = function (value) {\n        return value;\n      };\n      converters[Number] = function (value) {\n        return parseInt(value, 10);\n      };\n      converters[Boolean] = function (value) {\n        return value.toLowerCase() === 'true';\n      };\n      converters[RegExp] = function (value) {\n        return new RegExp(value);\n      };\n      converters[Object] = function (value) {\n        return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' ? value : Object(value);\n      };\n\n      return {\n        load: function load(directive, scope, attrs, options) {\n          scope.options = {};\n          scope.attrs = attrs;\n          scope.uid = _.uniqueId();\n\n          angular.forEach(options, function (value, key) {\n            var type, localDefault, converter, getDefault, updateValue;\n\n            type = value[0];\n            localDefault = value[1];\n            converter = converters[type];\n\n            getDefault = function getDefault() {\n              var globalValue = globalDefaults[directive] && globalDefaults[directive][key];\n              return angular.isDefined(globalValue) ? globalValue : localDefault;\n            };\n\n            updateValue = function updateValue(value) {\n              scope.options[key] = value ? converter(value) : getDefault();\n            };\n\n            if (scope[key]) {\n              updateValue(scope[key]);\n            } else if (interpolationStatus[directive] && interpolationStatus[directive][key]) {\n              attrs.$observe(key, function (value) {\n                updateValue(value);\n              });\n            } else {\n              updateValue(attrs[key] && $interpolate(attrs[key])(scope.$parent));\n            }\n          });\n        }\n      };\n    }];\n  });\n\n  /* HTML templates */\n  tagsInput.run([\"$templateCache\", function ($templateCache) {\n    $templateCache.put('cnTagsInput/tags-input.html', '\\n        <ul class=\"list-group cn-autocomplete-list\"\\n            ng-if=\"options.tagsStyle === \\'list\\' && tagList.items.length && !options.hideTags\">\\n          <li class=\"list-group-item {{options.tagClass}}\"\\n              ng-repeat=\"tag in tagList.items\"\\n              ng-class=\"{ selected: tag == tagList.selected }\">\\n            <button ng-if=\"!ngDisabled\"\\n                    ng-click=\"tagList.remove($index)\"\\n                    type=\"button\" class=\"close pull-right\">\\n              <span>&times;</span>\\n            </button>\\n            <span class=\"tag-item\" ng-bind-html=\"getDisplayHtml(tag)\"/>\\n          </li>\\n        </ul>\\n        <div class=\"host clearfix\"\\n             ng-hide=\"showBulk\"\\n             ti-transclude-append=\"\">\\n          <!-- hack to avoid browser\\'s autocomplete -->\\n          <input class=\"offscreen\"\\n                 id=\"fake-{{attrs.id && attrs.id}}-input\"\\n                 name=\"fake-{{attrs.id && attrs.id}}-input\">\\n          <!-- end hack to avoid browser\\'s autocomplete -->\\n          <div class=\"input form-control tags\"\\n               ng-class=\"{focused: hasFocus}\"\\n               ng-disabled=\"ngDisabled\">\\n            <input class=\"input\"\\n                   ng-disabled=\"ngDisabled\"\\n                   id=\"{{attrs.inputId || attrs.id && attrs.id + \\'-input-\\' + uid}}\"\\n                   name=\"{{attrs.inputId || attrs.id && attrs.id + \\'-input-\\' + uid}}\"\\n                   placeholder=\"{{options.placeholder}}\"\\n                   tabindex=\"{{options.tabindex}}\"\\n                   ng-model=\"newTag.text\"\\n                   ng-model-options=\"{updateOn: \\'default\\'}\"\\n                   ng-change=\"newTagChange()\"\\n                   ng-trim=\"false\"\\n                   ng-class=\"{\\n                      \\'invalid-tag\\': newTag.invalid,\\n                      \\'hide-below\\': options.maxTags === 1 && tagList.items.length\\n                   }\"\\n                   ti-autosize=\"\"\\n                   autocomplete=\"off\">\\n            <span class=\"tag-item label {{options.tagClass}} label-block\"\\n                  ng-if=\"options.tagsStyle !== \\'list\\' && !options.hideTags && options.maxTags === 1 && tagList.items.length\"\\n                  title=\"{{getDisplayText(tagList.items[0])}}\">\\n              <span ng-bind-html=\"getDisplayHtml(tagList.items[0])\"/>\\n              <a class=\"remove-button\"\\n                 ng-if=\"!ngDisabled && !options.dropdownIcon\"\\n                 ng-click=\"tagList.remove()\">\\n                <span>&times;</span>\\n              </a>\\n            </span>\\n            <ul class=\"tag-list\"\\n                ng-if=\"options.tagsStyle !== \\'list\\' && !options.hideTags && options.maxTags !== 1\">\\n              <li class=\"tag-item label {{options.tagClass}} overflows-to-tooltip\"\\n                  ng-class=\"{ selected: tag == tagList.selected }\"\\n                  ng-mouseenter=\"handleShowTooltip($event)\"\\n                  ng-mouseleave=\"handleHideTooltip($event)\"\\n                  ng-repeat=\"tag in tagList.items\">\\n                <div class=\"overflows-to-tooltip\"\\n                     ng-bind-html=\"getDisplayHtml(tag)\"/>\\n                  <a class=\"remove-button\"\\n                     ng-if=\"!ngDisabled\"\\n                     ng-click=\"tagList.remove($index)\">\\n                    <span>&times;</span>\\n                  </a>\\n                <div class=\"tag-overflow-tooltip\">\\n                  {{ getDisplayText(tag) }}\\n                </div>\\n              </li>\\n            </ul>\\n            <button ng-if=\"options.showButton && options.dropdownIcon\"\\n                    class=\"btn form-control-icon\" ng-disabled=\"ngDisabled\" tabindex=\"-1\">\\n              <i class=\"{{options.dropdownStyle}}\"></i>\\n            </button>\\n          </div>\\n        </div>\\n        <div class=\"help-block\">\\n          <button\\n            class=\"btn btn-default btn-xs\"\\n            ng-show=\"options.allowBulk && !showBulk\"\\n            ng-click=\"showBulk = true\"\\n          > Batch\\n          </button>\\n          <button\\n            class=\"btn btn-default btn-xs\"\\n            ng-show=\"options.showClearAll && tagList.items.length\"\\n            ng-click=\"tagList.removeAll($event)\"\\n          > Clear\\n          </button>\\n          <button\\n            class=\"btn btn-default btn-xs\"\\n            ng-show=\"options.showClearCache && tagList.suggestionList\"\\n            ng-click=\"tagList.suggestionList.clearCache($event, newTag.text)\"\\n          > <i class=\"fa fa-repeat\"/> Update Data\\n          </button>\\n          <button\\n            class=\"btn btn-default btn-xs\"\\n            ng-show=\"options.allowBulk && !showBulk && tagList.items.length\"\\n            ng-click=\"tagList.copyAllToClipboard()\"\\n          > <i class=\"fa fa-copy\"/> Copy\\n          </button>\\n        </div>\\n        <div ng-show=\"showBulk\" class=\"clearfix\">\\n          <textarea class=\"form-control\" ng-model=\"bulkTags\" ng-model-options=\"{\\'updateOn\\': \\'input\\'}\" placeholder=\"{{options.bulkPlaceholder}}\"></textarea>\\n          <p class=\"help-block\">\\n            Press \"Enter\" to submit, \"Shift+Enter\" to add a new line\\n          </p>\\n          <p class=\"help-block\">\\n            Add multiple with brackets, eg. \"citizennet[10]\"\\n          </p>\\n          <div class=\"btn-group help-block\">\\n            <button class=\"btn btn-default btn-xs\" ng-click=\"showBulk = false\">Cancel</button>\\n          </div>\\n        </div>');\n\n    $templateCache.put('cnTagsInput/auto-complete.html', '\\n        <div ng-if=\"!suggestionList.items.length && !options.groupBy\"\\n             ng-class=\"{open: suggestionList.visible}\">\\n          <ul class=\"autocomplete dropdown-menu\">\\n            <li class=\"dropdown-header\" ng-bind-html=\"suggestionList.visible && noResultsMessage(suggestionList)\"></li>\\n          </ul>\\n        </div>\\n        <div ng-if=\"suggestionList.items.length && isGroups\"\\n             ng-class=\"{open: suggestionList.visible}\">\\n          <ul class=\"autocomplete dropdown-menu\">\\n            <li ng-if=\"!suggestionList.items[0].items.length && !suggestionList.items[1].items.length\" class=\"dropdown-header\">No results...</li>\\n            <li ng-repeat-start=\"group in suggestionList.items\"></li>\\n            <li class=\"dropdown-header\" ng-show=\"group.items.length\">{{group.label | titleCase}}</li>\\n            <li ng-repeat=\"item in group.items\"\\n                class=\"suggestion\"\\n                ng-class=\"{selected: item == suggestionList.selected, disabled: item.disabled}\"\\n                ng-click=\"addSuggestion($event)\"\\n                ng-mouseenter=\"suggestionList.select(group.indexes[$index])\"\\n                ng-bind-html=\"highlight(item, group.label)\">\\n            </li>\\n            <li class=\"divider\" ng-show=\"!$last && $parent.suggestionList.items[$index+1].items.length\"></li>\\n            <li ng-repeat-end></li>\\n          </ul>\\n        </div>\\n        <div ng-if=\"suggestionList.items.length && !isGroups && !options.groupBy\"\\n             ng-class=\"{open: suggestionList.visible}\">\\n          <ul class=\"autocomplete dropdown-menu\">\\n            <li ng-repeat=\"item in suggestionList.items\"\\n                class=\"suggestion\"\\n                ng-class=\"{selected: item == suggestionList.selected, disabled: item.disabled}\"\\n                ng-click=\"addSuggestion($event)\"\\n                ng-mouseenter=\"suggestionList.select($index)\"\\n                ng-bind-html=\"highlight(item)\">\\n            </li>\\n          </ul>\\n        </div>\\n        <div ng-if=\"!isGroups && options.groupBy\"\\n             ng-class=\"{open: suggestionList.visible}\">\\n          <ul class=\"autocomplete dropdown-menu\">\\n            <li ng-repeat-start=\"(group, items) in suggestionList.items\"></li>\\n            <li class=\"dropdown-header\" ng-show=\"items.length\">{{group | titleCase}}</li>\\n            <li ng-repeat=\"item in items\"\\n                class=\"suggestion\"\\n                ng-class=\"{selected: item == suggestionList.selected, disabled: item.disabled}\"\\n                ng-click=\"addSuggestion($event)\"\\n                ng-mouseenter=\"suggestionList.select(suggestionList.items[group].indexes[$index])\"\\n                ng-bind-html=\"highlight(item)\">\\n            </li>\\n            <li class=\"divider\" ng-show=\"!$last && items.length\"></li>\\n            <li ng-repeat-end></li>\\n          </ul>\\n        </div>');\n  }]);\n})();","/*!;\n  tagsInput = null;\n * ngTagsInput v2.0.1\n * http://mbenford.github.io/ngTagsInput\n *\n * Copyright (c) 2013-2014 Michael Benford\n * License: MIT\n *\n * Generated at 2014-04-13 21:25:38 -0300\n */\n(function() {\n  'use strict';\n\n  var KEYS = {\n    backspace: 8,\n    tab: 9,\n    enter: 13,\n    escape: 27,\n    space: 32,\n    up: 38,\n    down: 40,\n    comma: 188\n  };\n\n  function empty(obj) {\n    _.forOwn(obj, function(_value, key, coll) {\n      _.set(coll, key, null);\n    });\n  }\n\n  function SimplePubSub() {\n    var events = {};\n    return {\n      on: function(names, handler) {\n        names.split(' ').forEach(function(name) {\n          if(!events[name]) {\n            events[name] = [];\n          }\n          events[name].push(handler);\n        });\n        return this;\n      },\n      trigger: function(name, args) {\n        angular.forEach(events[name], function(handler) {\n          handler.call(null, args);\n        });\n        return this;\n      },\n      destroy: function() {\n        empty(events);\n        events = null;\n      }\n    };\n  }\n\n  function makeObjectArray(array, key, key2) {\n    array = array || [];\n    if(array.length > 0 && !angular.isObject(array[0])) {\n      array.forEach(function(item, index) {\n        array[index] = {\n          [key]: item\n        };\n        if(key2) array[index][key2] = item;\n      });\n    }\n    return array;\n  }\n\n  function getArrayModelVal(array, options) {\n    if(options.arrayValueType === 'object') {\n      return (array || []).map(item => _.isObject(item && item[options.valueProperty]) ? item[options.valueProperty] : item);\n    }\n    else {\n      return _.pluck(array, options.valueProperty);\n    }\n  }\n\n  function findInObjectArray(array, obj, key) {\n    var item = null;\n    var i = 0;\n    var l = array.length;\n\n    if(_.isFunction(key)) {\n      var objVal = key(obj);\n      if(!objVal) return null;\n      for(; i < l; i++) {\n        if(objVal === key(array[i])) {\n          item = array[i];\n          break;\n        }\n      }\n    }\n    else {\n      for(; i < l; i++) {\n        // I'm aware of the internationalization issues regarding toLowerCase()\n        // but I couldn't come up with a better solution right now\n        if(_.has(obj, key) &&\n            _.has(array[i], key) &&\n            (angular.toJson(array[i][key]) + '').toLowerCase() === (angular.toJson(obj[key]) + '').toLowerCase()) {\n          item = array[i];\n          break;\n        }\n      }\n    }\n    return item;\n  }\n\n  function replaceAll(str, substr, newSubstr) {\n    var expression = substr.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n    return str.replace(new RegExp(expression, 'gi'), newSubstr);\n  }\n\n  function matchTagsWithModel(tags, model, options) {\n    if(!model || !tags || !tags.length) return false;\n\n    if(!_.isArray(model)) {\n      return angular.equals(model, tags[0][options.valueProperty]) || angular.equals(model, tags[0]);\n    }\n\n    let array = getArrayModelVal(tags, options);\n    return _.some(array, (tag, i) => {\n      return angular.equals(model[i], tag) || angular.equals(model[i], tag[options.valueProperty]);\n    });\n  }\n\n  function findTagsForValue(tags, value, options) {\n    if(_.isArray(value)) {\n      var matches = _.filter(tags, tag => _.find(value, val =>\n                                                 matchTag(tag, val, options.valueProperty, options.arrayValueType)));\n\n      if(!options.addFromAutocompleteOnly && matches.length < value.length) {\n        _.each(value, v => {\n          if(!_.find(matches, m => matchTag(m, v, options.valueProperty, options.arrayValueType))) matches.push(v);\n        });\n      }\n\n      return matches;\n    }\n\n    return _.filter(tags, tag => matchTag(tag, value, options.valueProperty, options.modelType));\n  }\n\n  function matchTag(tag, value, valueProperty, modelType) {\n    var tagValue = valueProperty ? tag[valueProperty] : tag;\n    return modelType === 'object' ?\n      objectContains(value, tagValue) :\n      value == tagValue;\n  }\n\n  function objectContains(small, large) {\n    if(angular.isArray(small)) {\n      return angular.equals(small, large);\n    }\n    return _.every(small, (val, key) => {\n      return key === '$$hashKey' || (\n        angular.isObject(val) ?\n          objectContains(val, large[key]) :\n          val == large[key]\n      );\n    });\n  }\n\n  function selectAll(input) {\n    if(input.value) {\n      input.setSelectionRange(0, input.value.length);\n    }\n  }\n\n  function sortResults(results, tag, displayProperty) {\n    const valueFor = val => {\n      return displayProperty && val[displayProperty] ? val[displayProperty] : val;\n    };\n    var first = _.remove(results, result => {\n      return _.startsWith(valueFor(result), valueFor(tag));\n    });\n    first = _.sortBy(first, [\n      result => { return valueFor(result).length; }\n    ]);\n    const reTag = new RegExp(valueFor(tag), \"i\");\n    var second = _.remove(results, result => {\n      return reTag.test(valueFor(result));\n    });\n    second = _.sortBy(second, [\n      result => { return valueFor(result).search(reTag);},\n      result => { return valueFor(result).length; }\n    ]);\n    var third = _.sortBy(results, [\n      result => { return valueFor(result).length; }\n    ]);\n    return first.concat(second, third);\n  }\n\n  function copyToClipboard(text) {\n    if (!_.isString(text)) return;\n    var copyElement = document.createElement(\"textarea\");\n    copyElement.style.position = 'fixed';\n    copyElement.style.opacity = '0';\n    copyElement.textContent = text;\n    var body = document.getElementsByTagName('body')[0];\n    body.appendChild(copyElement);\n    copyElement.select();\n    document.execCommand('copy');\n    body.removeChild(copyElement);\n  }\n  \n  function stripHtml(html)\n  {\n    let tmp = document.createElement(\"DIV\");\n    tmp.innerHTML = html;\n    return tmp.textContent || tmp.innerText || \"\";\n  }\n\n  var tagsInput = angular.module('cnTagsInput', []);\n\n  /**\n   * @ngdoc directive\n   * @name tagsInput\n   * @module cnTagsInput\n   *\n   * @description\n   * Renders an input box with tag editing support.\n   *\n   * @param {string} ngModel Assignable angular expression to data-bind to.\n   * @param {string=} [displayProperty=text] Property to be rendered as the tag label.\n   * @param {string=} [valueProperty=value] Property to be used as the value when modelType is not array/object.\n   * @param {number=} tabindex Tab order of the control.\n   * @param {string=} [placeholder=Add a tag] Placeholder text for the control.\n   * @param {number=} [minLength=3] Minimum length for a new tag.\n   * @param {number=} maxLength Maximum length allowed for a new tag.\n   * @param {boolean=} required Sets required validation error key.\n   * @param {number=} minTags Sets minTags validation error key if the number of tags added is less than minTags.\n   * @param {number=} maxTags Sets maxTags validation error key if the number of tags added is greater than maxTags.\n   * @param {boolean=} [allowLeftoverText=false] Sets leftoverText validation error key if there is any leftover text in\n   *                                             the input element when the directive loses focus.\n   * @param {string=} [removeTagSymbol=×] Symbol character for the remove tag button.\n   * @param {boolean=} [addOnEnter=true] Flag indicating that a new tag will be added on pressing the ENTER key.\n   * @param {boolean=} [addOnSpace=false] Flag indicating that a new tag will be added on pressing the SPACE key.\n   * @param {boolean=} [addOnComma=true] Flag indicating that a new tag will be added on pressing the COMMA key.\n   * @param {boolean=} [addOnBlur=false] Flag indicating that a new tag will be added when the input field loses focus.\n   * @param {boolean=} [clearOnBlur=false] Flag indicating whether to clear the typed text when the input field loses focus.\n   * @param {boolean=} [replaceSpacesWithDashes=false] Flag indicating that spaces will be replaced with dashes.\n   * @param {string=} [allowedTagsPattern=.+] Regular expression that determines whether a new tag is valid.\n   * @param {boolean=} [enableEditingLastTag=false] Flag indicating that the last tag will be moved back into\n   *                                                the new tag input box instead of being removed when the backspace key\n   *                                                is pressed and the input box is empty.\n   * @param {boolean=} [addFromAutocompleteOnly=false] Flag indicating that only tags coming from the autocomplete list will be allowed.\n   *                                                   When this flag is true, addOnEnter, addOnComma, addOnSpace, addOnBlur and\n   *                                                   allowLeftoverText values are ignored.\n   * @param {expression} onBeforeTagAdded Expression to evaluate upon adding a new tag. The new tag is available as $tag.\n   * @param {expression} onBeforeTagRemoved Expression to evaluate upon removing an existing tag. The removed tag is available as $tag.\n   * @param {expression} onBeforeTagChanged Expression to evaluate upon adding or removing a tag. The affected tag is available as $tag. Prev value avialble as $prev.\n   * @param {expression} onTagAdded Expression to evaluate upon adding a new tag. The new tag is available as $tag.\n   * @param {expression} onTagRemoved Expression to evaluate upon removing an existing tag. The removed tag is available as $tag.\n   * @param {expression} onTagChanged Expression to evaluate upon adding or removing a tag. The affected tag is available as $tag. Prev value avialble as $prev.\n   * @param {expression} onInit Expression to evaluate upon initializing model value.\n   * @param {string} modelType Defines ngModel type, if anything other than array, model is set to first tag in list\n   * @param {string} arrayValueType Defines ngModel[] type, if anything other than object, value is set mapped from object's values\n   * @param {boolean=} [hideTags=false] Flag indicating whether to hide tag list (for manually displaying tag list in other way)\n   * @param {boolean=} [dropdownIcon=false] Flag to show icon on right side\n   * @param {string=} [tagsStyle='tags'] Default tags style\n   * @param {boolean=} sortFilteredResults Flag to set whether to sort autocomplete list\n   */\n  tagsInput.directive('tagsInput', [\n    \"$timeout\", \"$document\", \"tagsInputConfig\", \"$sce\", \"$rootScope\",\n    function($timeout, $document, tagsInputConfig, $sce, $rootScope) {\n      function TagList(options, events) {\n        var self = {}, getTagText, setTagText, tagIsValid;\n\n        getTagText = options.getTagText = function(tag) {\n          if(!_.isObject(tag)) return tag;\n          return options.itemFormatter ? options.itemFormatter(tag) : tag[options.displayProperty];\n        };\n\n        setTagText = function(tag, text) {\n          // only create tag object when not adding from auto-complete\n          if(tag[options.displayProperty]) return;\n\n          tag[options.displayProperty] = text;\n          if(options.valueProperty && !_.has(tag, options.valueProperty)) {\n            tag[options.valueProperty] = text;\n          }\n        };\n\n        tagIsValid = function(tag) {\n          var tagText = getTagText(tag) + '';\n\n          return (!options.minLength || tagText.length >= options.minLength) &&\n                 (!options.maxLength || tagText.length <= options.maxLength) &&\n                 options.allowedTagsPattern.test(tagText) &&\n                 !findInObjectArray(\n                     self.items,\n                     tag,\n                     options.valueProperty || getTagText\n                 );\n        };\n\n        self.items = [];\n\n        self.addText = function(text) {\n          var tag = {};\n          setTagText(tag, text);\n          self.add(tag);\n        };\n\n        self.add = function(tag) {\n          if(tag.disabled) return;\n\n          var tagText = getTagText(tag);\n\n          if(tagText.trim) tagText = tagText.trim();\n\n          if(options.replaceSpacesWithDashes) {\n            tagText = tagText.replace(/\\s/g, '-');\n          }\n\n          setTagText(tag, tagText);\n\n          if(tagIsValid(tag)) {\n            if(options.maxTags && self.items.length >= options.maxTags) {\n              self.items.pop();\n              events.trigger('tag-removed', {$tag: tag, $event: 'tag-removed'});\n            }\n            self.items.push(tag);\n            events.trigger('tag-added', {$tag: tag, $event: 'tag-added'});\n          }\n          else {\n            events.trigger('invalid-tag', {$tag: tag, $event: 'invalid-tag'});\n          }\n          return tag;\n        };\n\n        self.remove = function(index) {\n          var tag = self.items.splice(index, 1)[0];\n          events.trigger('tag-removed', {$tag: tag, $event: 'tag-removed'});\n          return tag;\n        };\n\n        self.removeLast = function() {\n          var tag, lastTagIndex = self.items.length - 1;\n\n          if(options.enableEditingLastTag || self.selected) {\n            self.selected = null;\n            tag = self.remove(lastTagIndex);\n          }\n          else if(!self.selected) {\n            self.selected = self.items[lastTagIndex];\n          }\n\n          return tag;\n        };\n\n        self.removeAll = function(e) {\n          e.preventDefault();\n          var tags = self.items.splice(0, self.items.length);\n          tags.forEach(function(tag) {\n            events.trigger('tag-removed', {$tag: tag, $event: 'tag-removed'});\n          });\n        };\n\n        self.copyAllToClipboard = () => copyToClipboard(self.items.map(getTagText).map(stripHtml).join('\\n'));\n\n        self.destroy = function() {\n          empty(self);\n          self = null;\n        };\n\n        return self;\n      }\n\n      return {\n        restrict: 'E',\n        require: 'ngModel',\n        scope: {\n          tags: '=ngModel',\n          itemFormatter: '=',\n          ngDisabled: '=',\n          onBeforeTagAdded: '&',\n          onBeforeTagRemoved: '&',\n          onBeforeTagChanged: '&',\n          onTagAdded: '&',\n          onTagRemoved: '&',\n          onTagChanged: '&',\n          onInit: '&',\n          newTag: '=?'\n        },\n        replace: false,\n        transclude: true,\n        templateUrl: 'cnTagsInput/tags-input.html',\n        controller: [\"$scope\", \"$attrs\", \"$element\", function($scope, $attrs, $element) {\n          tagsInputConfig.load('tagsInput', $scope, $attrs, {\n            placeholder: [String, ''],\n            tabindex: [Number],\n            removeTagSymbol: [String, String.fromCharCode(215)],\n            replaceSpacesWithDashes: [Boolean, false],\n            minLength: [Number, 2],\n            maxLength: [Number],\n            addOnEnter: [Boolean, true],\n            addOnSpace: [Boolean, false],\n            addOnComma: [Boolean, true],\n            addOnBlur: [Boolean, false],\n            clearOnBlur: [Boolean, false],\n            allowedTagsPattern: [RegExp, /.+/],\n            enableEditingLastTag: [Boolean, false],\n            required: [Boolean, false],\n            minTags: [Number],\n            maxTags: [Number],\n            displayProperty: [String, 'text'],\n            valueProperty: [String],\n            allowLeftoverText: [Boolean, false],\n            addFromAutocompleteOnly: [Boolean, false],\n            tagClass: [String, ''],\n            modelType: [String, 'array'],\n            arrayValueType: [String, 'object'],\n            hideTags: [Boolean, false],\n            dropdownIcon: [Boolean, false],\n            tagsStyle: [String, 'tags'],\n            allowBulk: [Boolean, false],\n            bulkSingleRequest: [String, ''],\n            bulkDelimiter: [RegExp, /, ?|\\n/],\n            bulkPlaceholder: [String, 'Enter a list separated by commas or new lines'],\n            sortFilteredResults: [Boolean, false],\n            showClearAll: [Boolean, false],\n            showClearCache: [Boolean, false],\n            showButton: [Boolean, false]\n          });\n\n          var options = $scope.options;\n          var input = options.input = $element.find('input.input');\n\n          function handleKeydown(e) {\n            $scope.events.trigger('input-keydown', e);\n          }\n\n          input.on('keydown', handleKeydown);\n\n          $scope.$on('$destroy', function() {\n            input.off('keydown', handleKeydown);\n            input = null;\n            empty(options);\n            options = null;\n            $scope.events.destroy();\n            $scope.tagList.destroy();\n            $scope.processBulk = null;\n          });\n\n          if(!options.valueProperty &&\n              (!/object|array/.test(options.modelType) || options.arrayValueType !== 'object')) {\n            options.valueProperty = 'value';\n          }\n\n          if($scope.itemFormatter) options.itemFormatter = $scope.itemFormatter;\n\n          if(options.tagsStyle === 'tags') {\n            options.tagClass = options.tagClass || 'label-primary';\n          }\n\n          if(options.allowBulk && (options.modelType !== 'array' || options.maxTags === 1)) {\n            options.allowBulk = false;\n          }\n\n          $scope.events = new SimplePubSub();\n          $scope.tagList = new TagList(options, $scope.events);\n\n          this.registerAutocomplete = function() {\n            return {\n              addTag: function(tag) {\n                return $scope.tagList.add(tag);\n              },\n              focusInput: function() {\n                input[0].focus();\n              },\n              blurInput: function() {\n                input[0].blur();\n              },\n              getTags: function() {\n                return $scope.tagList.items;\n              },\n              getModel: function() {\n                return $scope.tags;\n              },\n              getOptions: function() {\n                return options;\n              },\n              on: function(name, handler) {\n                $scope.events.on(name, handler);\n                return this;\n              },\n              registerProcessBulk: function(fn) {\n                $scope.processBulk = function() {\n                  fn($scope.bulkTags).then(function() {\n                    $scope.showBulk = false;\n                    $scope.bulkTags = '';\n                  });\n                };\n              },\n              registerSuggestionList: function(suggestionList) {\n                $scope.tagList.suggestionList = suggestionList;\n              }\n            };\n          };\n        }],\n        link: function(scope, element, attrs, ngModelCtrl) {\n          function tagsInputTag() {}\n          scope.__tag = new tagsInputTag();\n\n          var hotkeys = [KEYS.enter, KEYS.comma, KEYS.space, KEYS.backspace],\n              tagList = scope.tagList,\n              events = scope.events,\n              options = scope.options,\n              input = element.find('input.input'),\n              textarea = element.find('textarea'),\n              div = element.find('div'),\n              blurTimeout;\n\n          if(attrs.inputId && !ngModelCtrl.$name) {\n            ngModelCtrl.$name = attrs.inputId;\n          }\n\n          // before callbacks allow code to modify tag before it's added\n          // after callback fired after ngModel has chance to update\n          function beforeAndAfter(before, after) {\n            return function() {\n              var args = arguments;\n              before.apply(this, args);\n              $timeout(function(){\n                after.apply(this, args);\n              });\n            };\n          }\n\n          function inlineChangeTags() {\n            return function() {\n              if (arguments.length > 0 && _.isArray(arguments[0].$tag)) {\n                let newTags = arguments[0].$tag;\n                const isObjectArray = _.every(newTags, (v) => typeof v === 'object' && v !== null && options.displayProperty && v[options.displayProperty]);\n                if (isObjectArray) {\n                  if (scope.tagList && scope.tagList.items && newTags) {\n                    scope.tagList.items = newTags;\n                  }\n                }\n              }\n            };\n          }\n\n          events\n            .on('tag-added', beforeAndAfter(scope.onBeforeTagAdded, scope.onTagAdded))\n            .on('tag-removed', beforeAndAfter(scope.onBeforeTagRemoved, scope.onTagRemoved))\n            .on('tag-changed', beforeAndAfter(scope.onBeforeTagChanged, scope.onTagChanged))\n            .on('tag-changed', inlineChangeTags())\n            .on('tag-init', scope.onInit)\n            .on('tag-added tag-removed', function(e) {\n              if(!options.maxTags || options.maxTags > scope.tagList.items.length) {\n                selectAll(options.input[0]);\n              }\n              else {\n                scope.newTag.text = '';\n              }\n              if(options.modelType === 'array') {\n                if(!options.valueProperty) {\n                  scope.tags = scope.tagList.items;\n                }\n                else {\n                  scope.tags = getArrayModelVal(scope.tagList.items, options);\n                }\n                if (scope.tagList.items.length >= options.minTags) {\n                  ngModelCtrl.$setValidity('tv4-400', true);\n                }\n              }\n              else {\n                if(e.$event === 'tag-removed') {\n                  scope.tags = undefined;\n                }\n                else {\n                  if(!options.valueProperty) {\n                    scope.tags = e.$tag;\n                  }\n                  else {\n                    scope.tags = _.has(e.$tag, options.valueProperty) ?\n                        e.$tag[options.valueProperty] : e.$tag[options.displayProperty];\n                  }\n                }\n              }\n            })\n            .on('invalid-tag', function() {\n              scope.newTag.invalid = true;\n            })\n            .on('input-change', function() {\n              tagList.selected = null;\n              scope.newTag.invalid = null;\n            })\n            .on('input-focus', function() {\n              ngModelCtrl.$setValidity('leftoverText', true);\n            })\n            .on('input-blur', function() {\n              if(!options.addFromAutocompleteOnly) {\n                if(options.addOnBlur && scope.newTag.text) {\n                  tagList.addText(scope.newTag.text);\n                }\n              }\n\n              // Reset newTag\n              if(options.clearOnBlur) {\n                scope.newTag.text = '';\n                scope.newTag.invalid = null;\n              }\n            });\n\n          scope.newTag = {text: '', invalid: null};\n\n          scope.getDisplayText = scope.itemFormatter || function(tag) {\n            return tag && ((tag[options.displayProperty] || 'undefined') + '').trim();\n          };\n\n          scope.getDisplayHtml = function(tag) {\n            return $sce.trustAsHtml(scope.getDisplayText(tag));\n          };\n\n          scope.handleShowTooltip = (e) => {\n            var $target = $(e.target).closest('.tag-item.overflows-to-tooltip');\n            if ($target.outerWidth() === $target.offsetParent().width()) {\n              $target.find('.tag-overflow-tooltip').fadeIn(200);\n            }\n          };\n\n          scope.handleHideTooltip = (e) => {\n            $(e.target)\n              .closest('.tag-item.overflows-to-tooltip')\n              .find('.tag-overflow-tooltip')\n              .fadeOut(200);\n          };\n\n          scope.track = function(tag) {\n            return tag[options.displayProperty];\n          };\n\n          scope.newTagChange = function() {\n            events.trigger('input-change', scope.newTag.text);\n          };\n\n          scope.processBulk = scope.processBulk || function() {\n            var tags = scope.bulkTags.split(options.bulkDelimiter);\n            _.each(tags, function(text) {\n              var tag = {};\n              tag[options.displayProperty] = text;\n              scope.tagList.add(tag);\n            });\n            scope.showBulk = false;\n            scope.bulkTags = '';\n          };\n\n          var first = true;\n\n          scope.triggerInit = function(value, prev) {\n            var criteria = options.valueProperty ? {[options.valueProperty]: value} : value;\n            if(!tagList.items.length || !_.find(tagList.items, criteria)) {\n              events.trigger('tag-init', {\n                $tag: value,\n                $prev: prev,\n                $event: 'tag-init',\n                $setter: function(val) {\n                  if(val && !_.isObject(val)) {\n                    tagList.items = [{\n                      [options.displayProperty]: val,\n                      [options.valueProperty]: val\n                    }];\n                  }\n                  else {\n                    tagList.items = _.isArray(val) ? val : [val];\n                  }\n                  return tagList.items;\n                }\n              });\n            }\n          };\n\n          scope.$watch('tags', function(value, prev) {\n            var changed = !angular.equals(value, prev);\n            var init    = !changed && first;\n\n            if(init) {\n              scope.triggerInit(value, prev);\n            }\n            if(changed) {\n              events.trigger('tag-changed', {\n                $tag: value,\n                $prev: prev,\n                $event: 'tag-changed'\n              });\n            }\n\n            if(options.modelType === 'array') {\n              if(_.isArray(value)) {\n                if(value.length) {\n                  if(!matchTagsWithModel(tagList.items, scope.tags, options)) {\n                    scope.triggerInit(value, prev);\n                  }\n                  if(!matchTagsWithModel(tagList.items, scope.tags, options) || tagList.items.length !== scope.tags.length) {\n                    tagList.items = makeObjectArray(value, options.displayProperty, options.valueProperty);\n                    scope.tags = getArrayModelVal(tagList.items, options);\n                    return;\n                  }\n                }\n                else {\n                  tagList.items = [];\n                  if(angular.isUndefined(prev)) return;\n                }\n              }\n              else if(value === undefined) {\n                tagList.items = [];\n                scope.tags = [];\n                return;\n              }\n            }\n            else if(angular.isDefined(value)) {\n              if(_.isArray(value)) {\n                if(value.length) {\n                  //if(options.modelType === 'object') {\n                  if(!options.valueProperty) {\n                    scope.tags = value[0];\n                  }\n                  else {\n                    scope.tags = value[0][options.valueProperty];\n                  }\n\n                  return;\n                }\n                else {\n                  scope.tags = undefined;\n                }\n              }\n              else {\n                if(options.modelType === 'object') {\n                  if(value !== null) tagList.items = [value];\n                }\n                else {\n                  if(_.isObject(value)) {\n                    tagList.items = [value];\n\n                    var val = value[options.valueProperty];\n                    if(_.isUndefined(val)) val = value[options.displayProperty];\n                    scope.tags = val;\n\n                    return;\n                  }\n                  else if(!_.isUndefined(value) &&\n                      (!tagList.items.length || tagList.items[0][options.valueProperty] !== value)) {\n                    scope.triggerInit(value, prev);\n                  }\n                }\n              }\n            }\n            else if(!value && tagList.items.length) {\n              tagList.items = [];\n            }\n\n            if(!init && changed) {\n              ngModelCtrl.$setDirty();\n            }\n\n            // hack because schemaForm is incorrectly invalidating model sometimes\n            ngModelCtrl.$setValidity('schemaForm', true);\n            if(options.modelType === 'array') {\n              ngModelCtrl.$setValidity('tv4-401', value && options.maxTags ? value.length <= options.maxTags : true);\n              ngModelCtrl.$setValidity('tv4-302', value ? angular.isDefined(options.minTags) ? value.length >= options.minTags : true : false);\n            }\n            else {\n              if (!init) {\n                ngModelCtrl.$setValidity('tv4-302', !options.required || !(angular.isUndefined(value)));\n              }\n            }\n\n            first = false;\n\n          }, true);\n\n          function handleInputKeydown(e) {\n            // This hack is needed because jqLite doesn't implement stopImmediatePropagation properly.\n            // I've sent a PR to Angular addressing this issue and hopefully it'll be fixed soon.\n            // https://github.com/angular/angular.js/pull/4833\n            if(e.isImmediatePropagationStopped && e.isImmediatePropagationStopped()) {\n              return;\n            }\n\n            var key = e.keyCode,\n                isModifier = e.shiftKey || e.altKey || e.ctrlKey || e.metaKey,\n                addKeys = {},\n                shouldAdd, shouldRemove;\n\n            if(isModifier || hotkeys.indexOf(key) === -1) {\n              return;\n            }\n\n            addKeys[KEYS.enter] = options.addOnEnter;\n            addKeys[KEYS.comma] = options.addOnComma;\n            addKeys[KEYS.space] = options.addOnSpace;\n\n            shouldAdd = !options.addFromAutocompleteOnly && addKeys[key];\n            shouldRemove = !shouldAdd && key === KEYS.backspace && scope.newTag.text.length === 0;\n\n            if(shouldAdd) {\n              tagList.addText(scope.newTag.text);\n\n              scope.$apply();\n              e.preventDefault();\n            }\n            else if(shouldRemove) {\n              var tag = tagList.removeLast();\n              if(tag && options.enableEditingLastTag) {\n                scope.newTag.text = tag[options.displayProperty];\n              }\n\n              scope.$apply();\n              e.preventDefault();\n            }\n          }\n\n          function handleInputBlur(e) {\n            blurTimeout = $timeout(function() {\n              // race condition can cause input to be destroyed before timeout ends\n              if(!input) return false;\n              var activeElement = $document.prop('activeElement'),\n                  lostFocusToBrowserWindow = activeElement === input[0],\n                  lostFocusToChildElement = element.find('.host')[0].contains(activeElement);\n\n              if(lostFocusToBrowserWindow || !lostFocusToChildElement) {\n                scope.hasFocus = false;\n                events.trigger('input-blur', e);\n              }\n            }, 150); // timeout so that click event triggers first\n          }\n\n          function handleInputFocus(e) {\n            if(e) e.preventDefault();\n            if(scope.ngDisabled) return;\n\n            selectAll(e.target);\n\n            if(blurTimeout) $timeout.cancel(blurTimeout);\n\n            scope.hasFocus = true;\n            events.trigger('input-focus', input.val());\n\n            if(!/apply|digest/.test(scope.$root.$$phase)) scope.$apply();\n          }\n\n          function handleTextareaKeydown(e) {\n            if(e.keyCode === KEYS.enter) {\n              if(!e.altKey && !e.ctrlKey && !e.metaKey && !e.shiftKey) {\n                e.preventDefault();\n                scope.processBulk();\n              }\n            }\n          }\n\n          function handleDivClick(e) {\n            var $target = $(e.target);\n            if(!$target.closest('.suggestion').length &&\n               !$target.closest('.overflows-to-tooltip').length &&\n               // we don't want any of the buttons underneath to trigger\n               !$target.parent().hasClass('help-block')) {\n              e.preventDefault();\n              input[0].focus();\n            }\n          }\n\n          // stupid ugly hack to fix order between input and autocomplete events\n          let uglyHackTimeout = $timeout(function() {\n            input\n              .on('keydown', handleInputKeydown)\n              .on('focus', handleInputFocus)\n              .on('blur', handleInputBlur);\n          });\n\n          textarea.on('keydown', handleTextareaKeydown);\n\n          div.on('click', handleDivClick);\n\n          scope.$on('$destroy', function() {\n            input\n              .off('keydown', handleInputKeydown)\n              .off('focus', handleInputFocus)\n              .off('blur', handleInputBlur);\n\n            textarea.off('keydown', handleTextareaKeydown);\n            div.off('click', handleDivClick);\n            input = null;\n            textarea = null;\n            div = null;\n            events.destroy();\n            events = null;\n            first = null;\n            hotkeys = null;\n            options = null;\n            tagList = null;\n            $timeout.cancel(uglyHackTimeout);\n          });\n        }\n      };\n    }]);\n\n  /**\n   * @ngdoc directive\n   * @name autoComplete\n   * @module cnTagsInput\n   *\n   * @description\n   * Provides autocomplete support for the tagsInput directive.\n   *\n   * @param {expression} source Expression to evaluate upon changing the input content. The input value is available as\n   *                            $query. The result of the expression must be a promise that eventually resolves to an\n   *                            array of strings.\n   * @param {number=} [debounceDelay=100] Amount of time, in milliseconds, to wait before evaluating the expression in\n   *                                      the source option after the last keystroke.\n   * @param {number=} [minLength=3] Minimum number of characters that must be entered before evaluating the expression\n   *                                 in the source option.\n   * @param {boolean=} [highlightMatchedText=true] Flag indicating that the matched text will be highlighted in the\n   *                                               suggestions list.\n   * @param {number=} [maxResultsToShow=10] Maximum number of results to be displayed at a time.\n   */\n  tagsInput.directive('autoComplete', [\n    \"$document\", \"$timeout\", \"$filter\", \"$sce\", \"tagsInputConfig\", \"$parse\", 'Api', '$q',\n    function($document, $timeout, $filter, $sce, tagsInputConfig, $parse, Api, $q) {\n      function SuggestionList(scope, options) {\n        var self = {}, debouncedLoadId, getDifference, lastPromise, groupList,\n            splitListItems, formatItemText, mapIndexes;\n\n        groupList = function(list, groupBy) {\n          var filtered = {},\n              map = [],\n              index = 0,\n              keys;\n\n          // loop through each item in the list\n          _.each(list, function(item) {\n            keys = $parse(groupBy)(item);\n            if(!_.isArray(keys)) keys = [keys];\n            _.each(keys, function(key) {\n              if(!filtered[key]) {\n                filtered[key] = [];\n              }\n              filtered[key].push(item);\n            });\n          });\n\n          _.each(filtered, function(group) {\n            group.indexes = [];\n            _.each(group, function(item) {\n              group.indexes.push(index++);\n              map.push(item);\n            });\n          });\n\n          return {\n            groups: filtered,\n            map: map\n          };\n        };\n\n        formatItemText = function(item, formatter) {\n          if(formatter) {\n            if(!_.isArray(formatter)) {\n              formatter = [formatter, {}];\n            }\n            return $parse(formatter[0])((formatter[1].val = item) && formatter[1]);\n          }\n\n          return item;\n        };\n\n        splitListItems = function(items) {\n          var keys = [];\n\n          function addItem(key, item, group, prop) {\n            var text = _.isObject(item) ? item[prop || options.tagsInput.displayProperty] : item,\n                toAdd = {\n                  text: formatItemText(text, group.formatter),\n                  value: text,\n                  key: key,\n                  childKey: prop\n                };\n\n            if(!_.find(group.items, toAdd)) {\n              group.items.push(toAdd);\n            }\n          }\n\n          _.each(scope.searchKeys, function(group) {\n            var key = group.key;\n            group.items = [];\n\n            _.each(items, function(item) {\n              if(item[key]) {\n                if(_.isArray(item[key])) {\n                  _.each(item[key], function(child) {\n                    addItem(key, child, group, group.childKey);\n                  });\n                }\n                else {\n                  addItem(key, item[key], group, group.childKey);\n                }\n              }\n            });\n            keys.push(group);\n          });\n\n          return keys;\n        };\n\n        mapIndexes = function(items) {\n          var map = [],\n              index = 0;\n\n          _.each(items, function(group) {\n            group.indexes = [];\n            _.each(group.items, function(item) {\n              group.indexes.push(index++);\n              map.push(item);\n            });\n          });\n\n          return map;\n        };\n\n        getDifference = function(array1, array2) {\n          if(!array2.length) {\n            return array1.filter(function(item) {\n              return item[options.tagsInput.displayProperty] !== '';\n            });\n          }\n          return array1.filter(function(item) {\n            return !findInObjectArray(\n                array2,\n                item,\n                options.tagsInput.valueProperty || options.tagsInput.getTagText\n            );\n          });\n        };\n\n        self.reset = function() {\n          lastPromise = null;\n\n          self.items = [];\n          self.visible = false;\n          self.index = -1;\n          self.selected = null;\n          self.query = null;\n\n          $timeout.cancel(debouncedLoadId);\n        };\n\n        self.show = function() {\n          self.selected = null;\n          self.visible = true;\n          self.select(0);\n        };\n\n        self.load = function(query, tags) {\n          if(query.length < options.minLength) {\n            self.reset();\n            return;\n          }\n\n          var promise,\n              //filterBy = {},\n              filterBy = query,\n              groups,\n              processItems = function(items) {\n                if(promise && promise !== lastPromise) {\n                  return;\n                }\n\n                if(scope.searchKeys) {\n                  scope.isGroups = true;\n                  //filterBy = query;\n                  items = splitListItems(items);\n                }\n                if(_.isObject(items) && !_.isArray(items)) {\n                  scope.isGroups = true;\n                  items = _.map(items, function(list, group) {\n                    return {\n                      items: list,\n                      label: group\n                    };\n                  });\n                }\n                if(scope.isGroups) {\n                  _.each(items, function(group) {\n                    group.items = getDifference(group.items, tags);\n                    if(query) {\n                      let reconciliateItems = {};\n                      group.items.map((item, idx) => {\n                        item.__uniqueid = _.uniqueId('__uniqueid');\n                        reconciliateItems[item.__uniqueid] =_.cloneDeep(item);\n                        if ('key' in item) delete item.key;\n                        if ('childKey' in item) delete item.childKey;\n                      });\n                      group.items = $filter('cnFilter')(group.items, filterBy);\n                      if (options.tagsInput.sortFilteredResults) {\n                        group.items = sortResults(group.items, filterBy, options.tagsInput.displayProperty);\n                      }\n                      group.items.map((item) => {\n                        let ref = reconciliateItems[item.__uniqueid];\n                        if ('key' in ref) item.key = ref.key;\n                        if ('childKey' in ref) item.childKey = ref.childKey;\n                        delete item.__uniqueid;\n                      });\n                    }\n\n                    group.items = group.items.slice(0, options.maxResultsToShow);\n                  });\n                  self.itemMap = mapIndexes(items);\n                }\n                else {\n                  //filterBy[options.tagsInput.displayProperty] = query;\n                  items = makeObjectArray(items.data || items, options.tagsInput.displayProperty);\n                  items = getDifference(items, tags);\n                  if(query && !options.skipFiltering) {\n                    items = $filter('cnFilter')(items, filterBy);\n                  }\n\n                  if (options.tagsInput.sortFilteredResults) {\n                    items = sortResults(items, filterBy, options.tagsInput.displayProperty);\n                  }\n\n                  items = items.slice(0, options.maxResultsToShow);\n\n                  if(options.groupBy) {\n                    groups = groupList(items, options.groupBy);\n                    items = groups.groups;\n                    self.itemMap = groups.map;\n                  }\n                }\n\n                self.items = items;\n                self.show();\n              };\n\n          $timeout.cancel(debouncedLoadId);\n          self.query = query;\n          debouncedLoadId = $timeout(function() {\n            self._load(query, promise).then(processItems);\n          }, options.minLength ? options.debounceDelay : 0, false);\n        };\n\n        self.clearCache = function(event, query) {\n          event.preventDefault();\n          if(scope._source) scope.source = scope._source;\n          var source = scope.source;\n          source({$query: query, options: { refreshData: true }})\n            .then(function(results) {\n              scope._source = source;\n              scope.source = function() {\n                return results;\n              };\n              scope.tagsInput.focusInput();\n            });\n        };\n\n        self._load = function(query, promise) {\n          var d = $q.defer();\n          var source = scope.source({$query: query});\n          if(_.isArray(source)) {\n            $timeout(function() {\n              d.resolve(source || []);\n            });\n          }\n          else {\n            promise = source;\n            lastPromise = promise;\n            return promise;\n          }\n          return d.promise;\n        };\n\n        self.selectNext = function() {\n          self.select(++self.index);\n        };\n\n        self.selectPrior = function() {\n          self.select(--self.index);\n        };\n\n        self.select = function(index) {\n          var list = self.itemMap || self.items;\n          if(index < 0) {\n            index = list.length - 1;\n          }\n          else if(index >= list.length) {\n            index = 0;\n          }\n          self.index = index;\n          if(self.itemMap) {\n            self.selected = self.itemMap[index];\n          }\n          else {\n            self.selected = self.items[index];\n          }\n        };\n\n        return self;\n      }\n\n      function encodeHTML(value) {\n        return value ? value\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;') : '';\n      }\n\n      return {\n        restrict: 'E',\n        require: '^tagsInput',\n        scope: {\n          source: '&',\n          searchKeys: '=?'\n        },\n        templateUrl: function(elem, attrs) {\n          return attrs.customTemplateUrl || 'cnTagsInput/auto-complete.html';\n        },\n        link: function(scope, element, attrs, tagsInputCtrl) {\n          var hotkeys = [KEYS.enter, KEYS.tab, KEYS.escape, KEYS.up, KEYS.down],\n              suggestionList, tagsInput, options, getItemText, documentClick;\n\n          function autoCompleteTag() {}\n          scope.__tag = new autoCompleteTag();\n\n          tagsInputConfig.load('autoComplete', scope, attrs, {\n            debounceDelay: [Number, 250],\n            minLength: [Number, 3],\n            singleQuery: [Boolean, false],\n            highlightMatchedText: [Boolean, true],\n            maxResultsToShow: [Number, 75],\n            groupBy: [String, ''],\n            skipFiltering: [Boolean, false]\n          });\n\n          options = scope.options;\n\n          tagsInput = tagsInputCtrl.registerAutocomplete();\n          scope.tagsInput = tagsInput;\n\n          options.tagsInput = tagsInput.getOptions();\n\n          if(options.minLength === 0/* && _.isArray(scope.source())*/) {\n            options.tagsInput.dropdownIcon = true;\n            if(options.tagsInput.maxTags === 1) {\n              options.tagsInput.dropdownStyle = 'caret';\n            }\n            else {\n              options.tagsInput.dropdownStyle = 'fa fa-plus';\n            }\n          }\n          else {\n            options.tagsInput.dropdownStyle = 'fa fa-search';\n          }\n\n          suggestionList = new SuggestionList(scope, options);\n          tagsInput.registerSuggestionList(suggestionList);\n\n          getItemText = options.tagsInput.itemFormatter || function(item) {\n            return String(item[options.tagsInput.displayProperty]);\n          };\n\n          scope.suggestionList = suggestionList;\n\n          var tagsValue = tagsInput.getModel();\n\n          if(options.singleQuery && tagsValue && !angular.equals(tagsValue, [])) {\n            suggestionList._load().then(results => {\n              var tags = findTagsForValue(results, tagsValue, options.tagsInput);\n              var curTags = tagsInput.getTags();\n              if(!angular.equals(tags, curTags)) {\n                curTags.length = 0; // hack to get event to retrigger\n                tags.forEach(tag => tagsInput.addTag(tag));\n              }\n            });\n          }\n\n          scope.addSuggestion = function(e) {\n            e.preventDefault();\n\n            var added = false;\n\n            if(suggestionList.selected) {\n              tagsInput.addTag(angular.copy(suggestionList.selected));\n\n              if(!options.tagsInput.maxTags || tagsInput.getTags().length < options.tagsInput.maxTags) {\n                var i = suggestionList.items.indexOf(suggestionList.selected);\n                suggestionList.items.splice(i, 1);\n                suggestionList.select(i);\n                tagsInput.focusInput();\n              }\n              else {\n                suggestionList.reset();\n                tagsInput.blurInput();\n              }\n\n              added = true;\n            }\n            return added;\n          };\n\n          scope.highlight = function(item, key) {\n            var text = getItemText(item, key);\n            if(suggestionList.query && options.highlightMatchedText) {\n              text =\n                _(text.match(/(<[^>]*>|[^<]*)/g)) // regex will create a list of all html and text nodes\n                .map(s => s.length && s[0] !== '<' ? replaceAll(s, suggestionList.query, '<b>$&</b>') : s)\n                .join('');\n            }\n            return $sce.trustAsHtml('<a>' + text + '</a>');\n          };\n\n          scope.track = function(item, key) {\n            return getItemText(item, key);\n          };\n\n          scope.noResultsMessage = function({visible, query}) {\n            if(!query) return 'No options...';\n            return $sce.trustAsHtml(`No results for <b>${query}</b>...`);\n          };\n\n          tagsInput.registerProcessBulk(function(bulkTags) {\n            var tags = bulkTags.split(options.tagsInput.bulkDelimiter);\n            var addTags = function(i) {\n              return function(data) {\n                _.times(i, function(i) {\n                  if(data[i]) tagsInput.addTag(data[i]);\n                });\n              };\n            };\n\n            if (options.tagsInput.bulkSingleRequest) {\n              let request_config = JSON.parse(options.tagsInput.bulkSingleRequest);\n              return Api.post({\n                url: request_config.url,\n                data: {\n                  location_types: request_config.location_types,\n                  terms: tags,\n                }\n              }).then(response => {\n                response.map(item => {\n                  tagsInput.addTag(item);\n                });\n              });\n            }\n            // in case a query is involved...doesn't hurt to use even if not\n            return Api.batch(function() {\n              for(var i = 0, l = tags.length; i < l; i++) {\n                if(options.tagsInput.maxTags && tagsInput.getTags().length >= options.tagsInput.maxTags) break;\n                var tag = tags[i];\n                var times = 1;\n                var multiple = tags[i].match(/(.*) ?\\[(\\d+)\\]$/);\n\n                if(multiple) {\n                  tag = multiple[1];\n                  times = parseInt(multiple[2]);\n                }\n\n                var results = scope.source({$query: tag});\n\n                if(_.isArray(results)) {\n                  if(results.length) {\n                    if(!options.skipFiltering) {\n                      var filterBy = tag;\n                      results = $filter('cnFilter')(results, filterBy);\n                    }\n                    if (options.tagsInput.sortFilteredResults) {\n                      results = sortResults(results, tag, options.tagsInput.displayProperty);\n                    }\n                    addTags(times)(results);\n                  }\n                  else if(!options.tagsInput.addFromAutocompleteOnly) {\n                    tagsInput.addTag({\n                      [options.tagsInput.displayProperty]: tag,\n                      [options.tagsInput.valueProperty]: tag\n                    });\n                  }\n                }\n                else if(results.then) {\n                  results.then(addTags(times));\n                }\n              }\n            });\n          });\n\n          tagsInput\n            .on('input-change', function(value) {\n              if(value || !options.minLength) {\n                suggestionList.load(value, tagsInput.getTags());\n              }\n              else {\n                suggestionList.reset();\n              }\n            })\n            .on('input-focus', function(value) {\n              if(!suggestionList.visible) {\n                suggestionList.load(value, tagsInput.getTags());\n              }\n            })\n            .on('input-keydown', function(e) {\n              var key, handled;\n\n              if(hotkeys.indexOf(e.keyCode) === -1) {\n                return;\n              }\n\n              // This hack is needed because jqLite doesn't implement stopImmediatePropagation properly.\n              // I've sent a PR to Angular addressing this issue and hopefully it'll be fixed soon.\n              // https://github.com/angular/angular.js/pull/4833\n              var immediatePropagationStopped = false;\n              e.stopImmediatePropagation = function() {\n                immediatePropagationStopped = true;\n                e.stopPropagation();\n              };\n              e.isImmediatePropagationStopped = function() {\n                return immediatePropagationStopped;\n              };\n\n              if(suggestionList.visible) {\n                key = e.keyCode;\n                handled = false;\n\n                if(key === KEYS.down) {\n                  suggestionList.selectNext();\n                  handled = true;\n                }\n                else if(key === KEYS.up) {\n                  suggestionList.selectPrior();\n                  handled = true;\n                }\n                else if(key === KEYS.escape) {\n                  suggestionList.reset();\n                  handled = true;\n                }\n                else if(key === KEYS.enter) {\n                  handled = scope.addSuggestion(e);\n                }\n\n                if(handled) {\n                  e.preventDefault();\n                  e.stopImmediatePropagation();\n                  scope.$apply();\n                }\n              }\n            })\n            .on('input-blur', function(e) {\n              //changed to use document click or focus, as this fires too soon and cancels\n              //automcomplete click events\n              suggestionList.reset();\n            });\n\n          documentClick = function(e) {\n            if(e.isDefaultPrevented()) return;\n\n            if(suggestionList.visible) {\n              // if autocomplete option was selected, or click/focus triggered outside of directive\n              if(($(e.target).closest('.suggestion').length || !$(e.target).closest(element[0]).length) &&\n                  !(e.type === 'blur' && !/^(input|select|textarea|button|a)$/i.test(e.target.tagName))) {\n                suggestionList.reset();\n                if(!/apply|digest/.test(scope.$root.$$phase)) scope.$apply();\n              }\n            }\n          };\n\n          $document\n            .on('click', documentClick)\n            .on('blur', documentClick);\n\n          scope.$on('$destroy', function() {\n            $document\n              .off('click', documentClick)\n              .off('blur', documentClick);\n\n            empty(tagsInput);\n            tagsInput = null;\n\n            empty(options);\n            options = null;\n          });\n        }\n      };\n    }]);\n\n\n  /**\n   * @ngdoc directive\n   * @name tiTranscludeAppend\n   * @module cnTagsInput\n   *\n   * @description\n   * Re-creates the old behavior of ng-transclude. Used internally by tagsInput directive.\n   */\n  tagsInput.directive('tiTranscludeAppend', function() {\n    return function(scope, element, attrs, ctrl, transcludeFn) {\n      transcludeFn(function(clone) {\n        element.append(clone);\n      });\n    };\n  });\n\n  /**\n   * @ngdoc directive\n   * @name tiAutosize\n   * @module cnTagsInput\n   *\n   * @description\n   * Automatically sets the input's width so its content is always visible. Used internally by tagsInput directive.\n   */\n  tagsInput.directive('tiAutosize', function() {\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      link: function(scope, element, attrs, ctrl) {\n        var THRESHOLD = 3,\n            span, resize;\n\n        span = angular.element('<span class=\"input\"></span>');\n        span.css('display', 'none')\n            .css('visibility', 'hidden')\n            .css('width', 'auto')\n            .css('white-space', 'pre');\n\n        element.parent().append(span);\n\n        resize = function(originalValue) {\n          var value = originalValue, width;\n\n          if(angular.isString(value) && value.length === 0) {\n            value = attrs.placeholder;\n          }\n\n          if(value) {\n            span.text(value);\n            span.css('display', '');\n            width = span.prop('offsetWidth');\n            span.css('display', 'none');\n          }\n\n          element.css('width', width ? width + THRESHOLD + 'px' : '');\n\n          return originalValue;\n        };\n\n        ctrl.$parsers.unshift(resize);\n        ctrl.$formatters.unshift(resize);\n\n        attrs.$observe('placeholder', function(value) {\n          if(!ctrl.$modelValue) {\n            resize(value);\n          }\n        });\n      }\n    };\n  });\n\n  /**\n   * @ngdoc service\n   * @name tagsInputConfig\n   * @module cnTagsInput\n   *\n   * @description\n   * Sets global configuration settings for both tagsInput and autoComplete directives. It's also used internally to parse and\n   * initialize options from HTML attributes.\n   */\n  tagsInput.provider('tagsInputConfig', function() {\n    var globalDefaults = {}, interpolationStatus = {};\n\n    /**\n     * @ngdoc method\n     * @name setDefaults\n     * @description Sets the default configuration option for a directive.\n     * @methodOf tagsInputConfig\n     *\n     * @param {string} directive Name of the directive to be configured. Must be either 'tagsInput' or 'autoComplete'.\n     * @param {object} defaults Object containing options and their values.\n     *\n     * @returns {object} The service itself for chaining purposes.\n     */\n    this.setDefaults = function(directive, defaults) {\n      globalDefaults[directive] = defaults;\n      return this;\n    };\n\n    /***\n     * @ngdoc method\n     * @name setActiveInterpolation\n     * @description Sets active interpolation for a set of options.\n     * @methodOf tagsInputConfig\n     *\n     * @param {string} directive Name of the directive to be configured. Must be either 'tagsInput' or 'autoComplete'.\n     * @param {object} options Object containing which options should have interpolation turned on at all times.\n     *\n     * @returns {object} The service itself for chaining purposes.\n     */\n    this.setActiveInterpolation = function(directive, options) {\n      interpolationStatus[directive] = options;\n      return this;\n    };\n\n    this.$get = [\"$interpolate\", function($interpolate) {\n      var converters = {};\n      converters[String] = function(value) {\n        return value;\n      };\n      converters[Number] = function(value) {\n        return parseInt(value, 10);\n      };\n      converters[Boolean] = function(value) {\n        return value.toLowerCase() === 'true';\n      };\n      converters[RegExp] = function(value) {\n        return new RegExp(value);\n      };\n      converters[Object] = function(value) {\n        return typeof value === 'object' ? value : Object(value);\n      };\n\n      return {\n        load: function(directive, scope, attrs, options) {\n          scope.options = {};\n          scope.attrs = attrs;\n          scope.uid = _.uniqueId();\n\n          angular.forEach(options, function(value, key) {\n            var type, localDefault, converter, getDefault, updateValue;\n\n            type = value[0];\n            localDefault = value[1];\n            converter = converters[type];\n\n            getDefault = function() {\n              var globalValue = globalDefaults[directive] && globalDefaults[directive][key];\n              return angular.isDefined(globalValue) ? globalValue : localDefault;\n            };\n\n            updateValue = function(value) {\n              scope.options[key] = value ? converter(value) : getDefault();\n            };\n\n            if(scope[key]) {\n              updateValue(scope[key]);\n            }\n            else if(interpolationStatus[directive] && interpolationStatus[directive][key]) {\n              attrs.$observe(key, function(value) {\n                updateValue(value);\n              });\n            }\n            else {\n              updateValue(attrs[key] && $interpolate(attrs[key])(scope.$parent));\n            }\n          });\n        }\n      };\n    }];\n  });\n\n\n  /* HTML templates */\n  tagsInput.run([\"$templateCache\", function($templateCache) {\n    $templateCache.put('cnTagsInput/tags-input.html', `\n        <ul class=\"list-group cn-autocomplete-list\"\n            ng-if=\"options.tagsStyle === 'list' && tagList.items.length && !options.hideTags\">\n          <li class=\"list-group-item {{options.tagClass}}\"\n              ng-repeat=\"tag in tagList.items\"\n              ng-class=\"{ selected: tag == tagList.selected }\">\n            <button ng-if=\"!ngDisabled\"\n                    ng-click=\"tagList.remove($index)\"\n                    type=\"button\" class=\"close pull-right\">\n              <span>&times;</span>\n            </button>\n            <span class=\"tag-item\" ng-bind-html=\"getDisplayHtml(tag)\"/>\n          </li>\n        </ul>\n        <div class=\"host clearfix\"\n             ng-hide=\"showBulk\"\n             ti-transclude-append=\"\">\n          <!-- hack to avoid browser's autocomplete -->\n          <input class=\"offscreen\"\n                 id=\"fake-{{attrs.id && attrs.id}}-input\"\n                 name=\"fake-{{attrs.id && attrs.id}}-input\">\n          <!-- end hack to avoid browser's autocomplete -->\n          <div class=\"input form-control tags\"\n               ng-class=\"{focused: hasFocus}\"\n               ng-disabled=\"ngDisabled\">\n            <input class=\"input\"\n                   ng-disabled=\"ngDisabled\"\n                   id=\"{{attrs.inputId || attrs.id && attrs.id + '-input-' + uid}}\"\n                   name=\"{{attrs.inputId || attrs.id && attrs.id + '-input-' + uid}}\"\n                   placeholder=\"{{options.placeholder}}\"\n                   tabindex=\"{{options.tabindex}}\"\n                   ng-model=\"newTag.text\"\n                   ng-model-options=\"{updateOn: 'default'}\"\n                   ng-change=\"newTagChange()\"\n                   ng-trim=\"false\"\n                   ng-class=\"{\n                      'invalid-tag': newTag.invalid,\n                      'hide-below': options.maxTags === 1 && tagList.items.length\n                   }\"\n                   ti-autosize=\"\"\n                   autocomplete=\"off\">\n            <span class=\"tag-item label {{options.tagClass}} label-block\"\n                  ng-if=\"options.tagsStyle !== 'list' && !options.hideTags && options.maxTags === 1 && tagList.items.length\"\n                  title=\"{{getDisplayText(tagList.items[0])}}\">\n              <span ng-bind-html=\"getDisplayHtml(tagList.items[0])\"/>\n              <a class=\"remove-button\"\n                 ng-if=\"!ngDisabled && !options.dropdownIcon\"\n                 ng-click=\"tagList.remove()\">\n                <span>&times;</span>\n              </a>\n            </span>\n            <ul class=\"tag-list\"\n                ng-if=\"options.tagsStyle !== 'list' && !options.hideTags && options.maxTags !== 1\">\n              <li class=\"tag-item label {{options.tagClass}} overflows-to-tooltip\"\n                  ng-class=\"{ selected: tag == tagList.selected }\"\n                  ng-mouseenter=\"handleShowTooltip($event)\"\n                  ng-mouseleave=\"handleHideTooltip($event)\"\n                  ng-repeat=\"tag in tagList.items\">\n                <div class=\"overflows-to-tooltip\"\n                     ng-bind-html=\"getDisplayHtml(tag)\"/>\n                  <a class=\"remove-button\"\n                     ng-if=\"!ngDisabled\"\n                     ng-click=\"tagList.remove($index)\">\n                    <span>&times;</span>\n                  </a>\n                <div class=\"tag-overflow-tooltip\">\n                  {{ getDisplayText(tag) }}\n                </div>\n              </li>\n            </ul>\n            <button ng-if=\"options.showButton && options.dropdownIcon\"\n                    class=\"btn form-control-icon\" ng-disabled=\"ngDisabled\" tabindex=\"-1\">\n              <i class=\"{{options.dropdownStyle}}\"></i>\n            </button>\n          </div>\n        </div>\n        <div class=\"help-block\">\n          <button\n            class=\"btn btn-default btn-xs\"\n            ng-show=\"options.allowBulk && !showBulk\"\n            ng-click=\"showBulk = true\"\n          > Batch\n          </button>\n          <button\n            class=\"btn btn-default btn-xs\"\n            ng-show=\"options.showClearAll && tagList.items.length\"\n            ng-click=\"tagList.removeAll($event)\"\n          > Clear\n          </button>\n          <button\n            class=\"btn btn-default btn-xs\"\n            ng-show=\"options.showClearCache && tagList.suggestionList\"\n            ng-click=\"tagList.suggestionList.clearCache($event, newTag.text)\"\n          > <i class=\"fa fa-repeat\"/> Update Data\n          </button>\n          <button\n            class=\"btn btn-default btn-xs\"\n            ng-show=\"options.allowBulk && !showBulk && tagList.items.length\"\n            ng-click=\"tagList.copyAllToClipboard()\"\n          > <i class=\"fa fa-copy\"/> Copy\n          </button>\n        </div>\n        <div ng-show=\"showBulk\" class=\"clearfix\">\n          <textarea class=\"form-control\" ng-model=\"bulkTags\" ng-model-options=\"{'updateOn': 'input'}\" placeholder=\"{{options.bulkPlaceholder}}\"></textarea>\n          <p class=\"help-block\">\n            Press \"Enter\" to submit, \"Shift+Enter\" to add a new line\n          </p>\n          <p class=\"help-block\">\n            Add multiple with brackets, eg. \"citizennet[10]\"\n          </p>\n          <div class=\"btn-group help-block\">\n            <button class=\"btn btn-default btn-xs\" ng-click=\"showBulk = false\">Cancel</button>\n          </div>\n        </div>`\n    );\n\n    $templateCache.put('cnTagsInput/auto-complete.html', `\n        <div ng-if=\"!suggestionList.items.length && !options.groupBy\"\n             ng-class=\"{open: suggestionList.visible}\">\n          <ul class=\"autocomplete dropdown-menu\">\n            <li class=\"dropdown-header\" ng-bind-html=\"suggestionList.visible && noResultsMessage(suggestionList)\"></li>\n          </ul>\n        </div>\n        <div ng-if=\"suggestionList.items.length && isGroups\"\n             ng-class=\"{open: suggestionList.visible}\">\n          <ul class=\"autocomplete dropdown-menu\">\n            <li ng-if=\"!suggestionList.items[0].items.length && !suggestionList.items[1].items.length\" class=\"dropdown-header\">No results...</li>\n            <li ng-repeat-start=\"group in suggestionList.items\"></li>\n            <li class=\"dropdown-header\" ng-show=\"group.items.length\">{{group.label | titleCase}}</li>\n            <li ng-repeat=\"item in group.items\"\n                class=\"suggestion\"\n                ng-class=\"{selected: item == suggestionList.selected, disabled: item.disabled}\"\n                ng-click=\"addSuggestion($event)\"\n                ng-mouseenter=\"suggestionList.select(group.indexes[$index])\"\n                ng-bind-html=\"highlight(item, group.label)\">\n            </li>\n            <li class=\"divider\" ng-show=\"!$last && $parent.suggestionList.items[$index+1].items.length\"></li>\n            <li ng-repeat-end></li>\n          </ul>\n        </div>\n        <div ng-if=\"suggestionList.items.length && !isGroups && !options.groupBy\"\n             ng-class=\"{open: suggestionList.visible}\">\n          <ul class=\"autocomplete dropdown-menu\">\n            <li ng-repeat=\"item in suggestionList.items\"\n                class=\"suggestion\"\n                ng-class=\"{selected: item == suggestionList.selected, disabled: item.disabled}\"\n                ng-click=\"addSuggestion($event)\"\n                ng-mouseenter=\"suggestionList.select($index)\"\n                ng-bind-html=\"highlight(item)\">\n            </li>\n          </ul>\n        </div>\n        <div ng-if=\"!isGroups && options.groupBy\"\n             ng-class=\"{open: suggestionList.visible}\">\n          <ul class=\"autocomplete dropdown-menu\">\n            <li ng-repeat-start=\"(group, items) in suggestionList.items\"></li>\n            <li class=\"dropdown-header\" ng-show=\"items.length\">{{group | titleCase}}</li>\n            <li ng-repeat=\"item in items\"\n                class=\"suggestion\"\n                ng-class=\"{selected: item == suggestionList.selected, disabled: item.disabled}\"\n                ng-click=\"addSuggestion($event)\"\n                ng-mouseenter=\"suggestionList.select(suggestionList.items[group].indexes[$index])\"\n                ng-bind-html=\"highlight(item)\">\n            </li>\n            <li class=\"divider\" ng-show=\"!$last && items.length\"></li>\n            <li ng-repeat-end></li>\n          </ul>\n        </div>`\n    );\n  }]);\n})();\n"]}